{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "links": [],
  "panels": [
    {
      "datasource": {
        "type": "datasource",
        "uid": "grafana"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 25,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 9,
      "options": {
        "afterRender": "// EXTERNAL({\"panel_id\":\"multimap-forecast-evaluation\",\"key\":\"params\"}):bfd145p7u3jlse-multimap-forecast-evaluation-params.js\nconst PROTOMAPS_KEY = \"320f86609595a624\";\nconst BASE_STYLE_URL_TEMPLATE =\n    \"https://api.protomaps.com/styles/v5/{flavor}/{lang}.json?key={key}\";\nconst TERRACOTTA_BASE_URL = \"https://terracotta.shared.rhizaresearch.org\";\nconst MAP_CONTAINER_ITEM_CLASS = \"map-container\";\nconst MAP_CONTAINER_ID = \"map-container\";\nconst TERRACOTTA_LAYER_ID = \"terracotta-raster\";\nconst TERRACOTTA_OPACITY = 0.9;\nconst RASTER_CROSSFADE_MS = 0;\nconst RASTER_LOAD_TIMEOUT_MS = 1800;\nconst DEFAULT_FLAVOR = \"black\";\nconst BASE_STYLE_LANG = \"en\";\nconst ALLOWED_SOURCE_LAYERS = [\n    \"boundaries\",\n    \"earth\",\n    \"landcover\",\n    \"places\",\n    \"water\",\n];\nconst MANAGED_OVERLAY_GROUPS = [\n    { key: \"hydroFills\", type: \"fill\", sourceLayer: \"water\" },\n    { key: \"hydroLines\", type: \"line\", sourceLayer: \"water\" },\n    { key: \"adminLines\", type: \"line\", sourceLayer: \"boundaries\" },\n    {\n        key: \"adminBoundaryLabels\",\n        type: \"symbol\",\n        sourceLayer: \"boundaries\",\n    },\n    { key: \"adminAreaLabels\", type: \"symbol\", sourceLayer: \"places\" },\n];\nconst BOUNDARY_CONTRAST = {\n    lineStrokeColor: \"rgba(255,255,255,0.92)\",\n    lineStrokeOpacity: 0.95,\n    lineCasingColor: \"rgba(0,0,0,0.85)\",\n    lineCasingOpacity: 0.9,\n    lineCasingExtraWidth: 1.8,\n    labelTextColor: \"#ffffff\",\n    labelHaloColor: \"#000000\",\n    labelHaloWidth: 1.8,\n    labelHaloBlur: 0.3,\n};\nconst POLL_INTERVAL_MS = 300;\nconst VAR_STABILIZE_MS = 700;\n\nconst MULTIMAP_PRODUCTS = [\n    { key: \"rain\", label: \"Precipitation\", product: \"era5_precip\" },\n    { key: \"temp\", label: \"Temperature\", product: \"era5_tmp2m\" },\n];\n\nconst replaceVariables =\n    typeof context !== \"undefined\" &&\n        context?.grafana?.replaceVariables &&\n        typeof context.grafana.replaceVariables === \"function\"\n        ? context.grafana.replaceVariables.bind(context.grafana)\n        : (value) => value;\n\nconst readVar = (name, fallback = \"\") => {\n    const token = `\\${${name}}`;\n    const value = replaceVariables(token);\n    if (value === token || value === undefined || value === null || value === \"\") {\n        return fallback;\n    }\n    return value;\n};\n\nconst readVars = () => ({\n    forecast: readVar(\"forecast\"),\n    grid: readVar(\"grid\"),\n    metric: readVar(\"metric\"),\n    timeGrouping: readVar(\"time_grouping\"),\n    timeFilter: readVar(\"time_filter\", \"None\"),\n    maxLead: Number(readVar(\"max_lead\", \"6\")) || 6,\n});\n\nfunction resolveRegion(forecast) {\n    return forecast === \"salient\" ? \"africa\" : \"global\";\n}\n\nfunction getLeadWeeks(maxLead) {\n    const safeMax = Math.max(1, Math.floor(Number(maxLead) || 1));\n    return Array.from({ length: safeMax }, (_, idx) => idx + 1);\n}\n\nlet VARS = readVars();\nlet stretchRequestController = null;\nlet maplibreReady = null;\nlet syncMoveReady = null;\n// EXTERNAL:maplibre-map-builder.js\nfunction buildStyleUrl(flavor) {\n    return BASE_STYLE_URL_TEMPLATE.replace(\"{flavor}\", flavor)\n        .replace(\"{lang}\", BASE_STYLE_LANG)\n        .replace(\"{key}\", PROTOMAPS_KEY);\n}\n\nasync function fetchPreparedStyle(flavor) {\n    const response = await fetch(buildStyleUrl(flavor));\n    if (!response.ok) {\n        throw new Error(`Style request failed (${response.status}).`);\n    }\n    const rawStyle = await response.json();\n    return prepareStyle(rawStyle);\n}\n\nfunction prepareStyle(styleJson) {\n    const allowedSourceLayers = new Set(ALLOWED_SOURCE_LAYERS);\n    const filteredLayers = (styleJson.layers || [])\n        .filter((layer) => {\n            const sourceLayer = layer[\"source-layer\"];\n            if (!sourceLayer) {\n                return true;\n            }\n            return (\n                allowedSourceLayers.size === 0 ||\n                allowedSourceLayers.has(sourceLayer)\n            );\n        })\n        .map((layer) => {\n            if (layer.type !== \"fill\" || layer[\"source-layer\"] !== \"water\") {\n                return layer;\n            }\n            return {\n                ...layer,\n                paint: {\n                    ...(layer.paint || {}),\n                    \"fill-opacity\": 0.8,\n                },\n            };\n        });\n\n    return {\n        ...styleJson,\n        layers: filteredLayers,\n        sprite: `https://protomaps.github.io/basemaps-assets/sprites/v4/${DEFAULT_FLAVOR}`,\n    };\n}\n\nfunction getGroupedManagedLayers(map) {\n    if (!map || !map.getStyle) {\n        return {};\n    }\n    const style = map.getStyle();\n    const groups = {};\n    const claimed = new Set();\n    MANAGED_OVERLAY_GROUPS.forEach((group) => {\n        groups[group.key] = [];\n        (style.layers || []).forEach((layer) => {\n            if (claimed.has(layer.id)) {\n                return;\n            }\n            if (\n                layer.type === group.type &&\n                layer[\"source-layer\"] === group.sourceLayer\n            ) {\n                groups[group.key].push(layer.id);\n                claimed.add(layer.id);\n            }\n        });\n    });\n    return groups;\n}\n\nfunction getManagedLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return MANAGED_OVERLAY_GROUPS.flatMap((group) => grouped[group.key] || []);\n}\n\nfunction getAdminBoundaryLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return grouped.adminLines || [];\n}\n\nfunction getBoundaryLabelLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return [...(grouped.adminBoundaryLabels || []), ...(grouped.adminAreaLabels || [])];\n}\n\nfunction applyBoundaryLineContrast(map, layerId) {\n    if (!map || !map.getLayer(layerId)) {\n        return;\n    }\n    const style = map.getStyle();\n    const layerDef = (style.layers || []).find((layer) => layer.id === layerId);\n    if (!layerDef) {\n        return;\n    }\n    const basePaint = layerDef.paint || {};\n    const baseWidth = basePaint[\"line-width\"] ?? 1;\n    const casingLayerId = `${layerId}__contrast_casing`;\n    if (map.getLayer(casingLayerId)) {\n        map.removeLayer(casingLayerId);\n    }\n\n    const casingPaint = {\n        ...basePaint,\n        \"line-color\": BOUNDARY_CONTRAST.lineCasingColor,\n        \"line-opacity\": BOUNDARY_CONTRAST.lineCasingOpacity,\n        \"line-width\": [\"+\", baseWidth, BOUNDARY_CONTRAST.lineCasingExtraWidth],\n    };\n\n    try {\n        map.addLayer(\n            {\n                ...layerDef,\n                id: casingLayerId,\n                paint: casingPaint,\n            },\n            layerId\n        );\n    } catch (error) {\n        console.warn(`Failed to add contrast casing for ${layerId}:`, error);\n    }\n\n    map.setPaintProperty(layerId, \"line-color\", BOUNDARY_CONTRAST.lineStrokeColor);\n    map.setPaintProperty(\n        layerId,\n        \"line-opacity\",\n        BOUNDARY_CONTRAST.lineStrokeOpacity\n    );\n}\n\nfunction applyBoundaryLabelContrast(map, layerId) {\n    if (!map || !map.getLayer(layerId)) {\n        return;\n    }\n    map.setPaintProperty(layerId, \"text-color\", BOUNDARY_CONTRAST.labelTextColor);\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-color\",\n        BOUNDARY_CONTRAST.labelHaloColor\n    );\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-width\",\n        BOUNDARY_CONTRAST.labelHaloWidth\n    );\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-blur\",\n        BOUNDARY_CONTRAST.labelHaloBlur\n    );\n}\n\nfunction applyBoundaryContrastOverrides(map) {\n    getAdminBoundaryLayerIds(map).forEach((layerId) => {\n        applyBoundaryLineContrast(map, layerId);\n    });\n    getBoundaryLabelLayerIds(map).forEach((layerId) => {\n        applyBoundaryLabelContrast(map, layerId);\n    });\n}\n\nfunction applyManagedOverlayLayerOrder(map) {\n    getManagedLayerIds(map).forEach((layerId) => {\n        if (!map.getLayer(layerId)) {\n            return;\n        }\n        try {\n            map.moveLayer(layerId);\n        } catch (error) {\n            console.warn(`Failed to move managed layer ${layerId}:`, error);\n        }\n    });\n}\n\nfunction getRasterInsertBeforeId(map) {\n    return getManagedLayerIds(map).find((layerId) => map.getLayer(layerId)) || null;\n}\n\nfunction getRasterSlotId(slot) {\n    return `${TERRACOTTA_LAYER_ID}-${slot}`;\n}\n\nfunction removeRasterSlot(map, slot) {\n    const slotId = getRasterSlotId(slot);\n    if (map.getLayer(slotId)) {\n        map.removeLayer(slotId);\n    }\n    if (map.getSource(slotId)) {\n        map.removeSource(slotId);\n    }\n}\n\nfunction setRasterLayer(map, tileUrl, slot = 0, opacity = TERRACOTTA_OPACITY) {\n    if (!map || !tileUrl) {\n        return;\n    }\n    const slotId = getRasterSlotId(slot);\n    removeRasterSlot(map, slot);\n\n    map.addSource(slotId, {\n        type: \"raster\",\n        tiles: [tileUrl],\n        tileSize: 256,\n    });\n\n    const layerDefinition = {\n        id: slotId,\n        type: \"raster\",\n        source: slotId,\n        paint: {\n            \"raster-opacity\": opacity,\n            \"raster-fade-duration\": 0,\n        },\n    };\n    const beforeLayerId = getRasterInsertBeforeId(map);\n    if (beforeLayerId) {\n        map.addLayer(layerDefinition, beforeLayerId);\n    } else {\n        map.addLayer(layerDefinition);\n    }\n    applyManagedOverlayLayerOrder(map);\n    return slotId;\n}\n\nfunction fadeRasterOpacity(map, layerId, fromOpacity, toOpacity, durationMs) {\n    if (!map.getLayer(layerId)) {\n        return Promise.resolve();\n    }\n    const clampOpacity = (value) => Math.max(0, Math.min(1, Number(value) || 0));\n    const safeFromOpacity = clampOpacity(fromOpacity);\n    const safeToOpacity = clampOpacity(toOpacity);\n    if (durationMs <= 0 || fromOpacity === toOpacity) {\n        map.setPaintProperty(layerId, \"raster-opacity\", safeToOpacity);\n        return Promise.resolve();\n    }\n    const start = performance.now();\n    return new Promise((resolve) => {\n        const step = (now) => {\n            if (!map.getLayer(layerId)) {\n                resolve();\n                return;\n            }\n            const t = Math.max(0, Math.min(1, (now - start) / durationMs));\n            const current = safeFromOpacity + (safeToOpacity - safeFromOpacity) * t;\n            map.setPaintProperty(layerId, \"raster-opacity\", clampOpacity(current));\n            if (t >= 1) {\n                resolve();\n                return;\n            }\n            requestAnimationFrame(step);\n        };\n        requestAnimationFrame(step);\n    });\n}\n\nasync function swapRasterLayer(runtime, tileUrl) {\n    const map = runtime?.map;\n    if (!map || !tileUrl) {\n        return;\n    }\n    const oldSlot = runtime.rasterSlot ?? 0;\n    const nextSlot = oldSlot === 0 ? 1 : 0;\n    const nextSlotId = setRasterLayer(map, tileUrl, nextSlot, 0);\n    const oldSlotId = getRasterSlotId(oldSlot);\n    const swapToken = (runtime.rasterSwapToken || 0) + 1;\n    runtime.rasterSwapToken = swapToken;\n\n    await new Promise((resolve) => {\n        let settled = false;\n        const finish = () => {\n            if (settled) {\n                return;\n            }\n            settled = true;\n            map.off(\"sourcedata\", onSourceData);\n            resolve();\n        };\n        const onSourceData = (event) => {\n            if (event.sourceId !== nextSlotId) {\n                return;\n            }\n            if (map.isSourceLoaded(nextSlotId)) {\n                finish();\n            }\n        };\n        map.on(\"sourcedata\", onSourceData);\n        window.setTimeout(finish, RASTER_LOAD_TIMEOUT_MS);\n    });\n\n    if (runtime.rasterSwapToken !== swapToken) {\n        return;\n    }\n\n    await Promise.all([\n        fadeRasterOpacity(\n            map,\n            nextSlotId,\n            0,\n            TERRACOTTA_OPACITY,\n            RASTER_CROSSFADE_MS\n        ),\n        fadeRasterOpacity(\n            map,\n            oldSlotId,\n            TERRACOTTA_OPACITY,\n            0,\n            RASTER_CROSSFADE_MS\n        ),\n    ]);\n\n    removeRasterSlot(map, oldSlot);\n    runtime.rasterSlot = nextSlot;\n}\n\nfunction getMaplibreGlobal() {\n    if (globalThis && globalThis.maplibregl) {\n        return globalThis.maplibregl;\n    }\n    if (window.maplibregl) {\n        return window.maplibregl;\n    }\n    if (window.parent && window.parent.maplibregl) {\n        return window.parent.maplibregl;\n    }\n    if (window.top && window.top.maplibregl) {\n        return window.top.maplibregl;\n    }\n    return null;\n}\n\nfunction waitForMaplibreGlobal(timeoutMs = 4000) {\n    return new Promise((resolve, reject) => {\n        if (getMaplibreGlobal()) {\n            resolve();\n            return;\n        }\n        const start = Date.now();\n        const tick = () => {\n            if (getMaplibreGlobal()) {\n                resolve();\n                return;\n            }\n            if (Date.now() - start > timeoutMs) {\n                reject(new Error(\"maplibregl global not available\"));\n                return;\n            }\n            window.setTimeout(tick, 50);\n        };\n        tick();\n    });\n}\n\nfunction loadMaplibre() {\n    if (getMaplibreGlobal()) {\n        return Promise.resolve();\n    }\n    if (maplibreReady) {\n        return maplibreReady;\n    }\n    maplibreReady = new Promise((resolve, reject) => {\n        const script = document.createElement(\"script\");\n        script.src = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js\";\n        script.crossOrigin = \"anonymous\";\n        script.onload = () => {\n            waitForMaplibreGlobal()\n                .then(() => {\n                    const global = getMaplibreGlobal();\n                    if (global && !window.maplibregl) {\n                        window.maplibregl = global;\n                    }\n                    resolve();\n                })\n                .catch(() => {\n                    import(\"https://esm.sh/maplibre-gl@3.6.2\")\n                        .then((module) => {\n                            window.maplibregl = module.default || module;\n                            return waitForMaplibreGlobal();\n                        })\n                        .then(resolve)\n                        .catch((error) => {\n                            reject(\n                                new Error(\n                                    `Failed to load maplibre-gl (global + esm). ${error}`\n                                )\n                            );\n                        });\n                });\n        };\n        script.onerror = () => {\n            import(\"https://esm.sh/maplibre-gl@3.6.2\")\n                .then((module) => {\n                    window.maplibregl = module.default || module;\n                    return waitForMaplibreGlobal();\n                })\n                .then(resolve)\n                .catch((error) => {\n                    reject(\n                        new Error(\n                            `Failed to load maplibre-gl.js and esm import. ${error}`\n                        )\n                    );\n                });\n        };\n        document.head.appendChild(script);\n    });\n    return maplibreReady;\n}\n\nfunction injectContainerAndStyles() {\n    const mapMountId = `${MAP_CONTAINER_ID}__mount`;\n    const existing = getOrCreateHostContainer();\n    if (existing.querySelector(`#${mapMountId}`)) {\n        const existingMount = document.getElementById(mapMountId);\n        return existingMount;\n    }\n\n    const style = document.createElement(\"style\");\n    style.textContent = `\n    :root {\n    --ink:#0c1f2e;\n    --panel:#f5f3ef;\n    }\n      .map-shell {\n        position:relative;\n        width:100%;\n        height:70vh;\n        min-height:60vh;\n    font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n    border-radius:18px;\n    overflow:hidden;\n    box-shadow:0 16px 40px rgba(8, 16, 28, 0.25);\n    border:1px solid rgba(12, 31, 46, 0.2);\n    background:#0b1220;\n    }\n      .map-mount {\n        position:absolute;\n        inset:0;\n        width:100%;\n        height:100%;\n      }\n    .maplibregl-canvas {\n    width:100% !important;\n    height:100% !important;\n    }\n    #map-colorscale {\n    position:absolute;\n    left:14px;\n    bottom:14px;\n    z-index:4;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    pointer-events:none;\n    background:rgba(245, 243, 239, 0.96);\n    color:var(--ink);\n    padding:4px 8px;\n    border-radius:10px;\n    border:1px solid rgba(12, 31, 46, 0.18);\n    font-size:11px;\n    line-height:1.2;\n    min-height:22px;\n    white-space:nowrap;\n    box-shadow:0 12px 24px rgba(8, 16, 28, 0.15);\n    }\n`;\n    document.head.appendChild(style);\n\n    const hostContainer = getOrCreateHostContainer();\n\n    hostContainer.innerHTML = `\n      <div class=\"map-shell\" id=\"map-shell-main\">\n        <div id=\"${mapMountId}\" class=\"map-mount\"></div>\n        <div id=\"map-colorscale\"></div>\n      </div>\n    `;\n\n    const css = document.createElement(\"link\");\n    css.rel = \"stylesheet\";\n    css.href = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css\";\n    document.head.appendChild(css);\n\n    loadMaplibre();\n    return document.getElementById(mapMountId);\n}\n\nfunction createSingleMapInstance(container, baseStyle) {\n    const mapContainer =\n        container || document.getElementById(`${MAP_CONTAINER_ID}__mount`) || MAP_CONTAINER_ID;\n    const fullscreenContainer =\n        typeof mapContainer?.closest === \"function\"\n            ? mapContainer.closest(\".map-shell\")\n            : document.getElementById(\"map-shell-main\");\n    function forceCompactAttribution(mapInstance) {\n        if (!mapInstance || !mapInstance.getContainer) return;\n        const root = mapInstance.getContainer();\n        const attributions = root.querySelectorAll(\".maplibregl-ctrl-attrib\");\n        attributions.forEach((control) => {\n            control.classList.add(\"maplibregl-compact\");\n            control.classList.remove(\"maplibregl-compact-show\");\n        });\n    }\n    const map = new window.maplibregl.Map({\n        container: mapContainer,\n        style: baseStyle,\n        center: [0, 20],\n        zoom: 1.2,\n        attributionControl: false,\n        cooperativeGestures: false,\n    });\n\n    map.addControl(\n        new window.maplibregl.NavigationControl({ showCompass: false })\n    );\n    map.addControl(\n        new window.maplibregl.FullscreenControl(\n            fullscreenContainer ? { container: fullscreenContainer } : {}\n        ),\n        \"top-right\"\n    );\n    map.addControl(\n        new window.maplibregl.AttributionControl({ compact: true })\n    );\n    map.on(\"load\", () => forceCompactAttribution(map));\n    window.setTimeout(() => forceCompactAttribution(map), 0);\n\n    return map;\n}\n// EXTERNAL:color_utilities.js\nfunction getColorStops(colormap) {\n    const palette = colormap.endsWith(\"_r\") ? colormap.slice(0, -2) : colormap;\n    const paletteStops = {\n        brbg: [\n            \"#543005\",\n            \"#8c510a\",\n            \"#bf812d\",\n            \"#dfc27d\",\n            \"#f6e8c3\",\n            \"#f5f5f5\",\n            \"#c7eae5\",\n            \"#80cdc1\",\n            \"#35978f\",\n            \"#01665e\",\n            \"#003c30\",\n        ],\n        rdbu: [\n            \"#67001f\",\n            \"#b2182b\",\n            \"#d6604d\",\n            \"#f4a582\",\n            \"#fddbc7\",\n            \"#f7f7f7\",\n            \"#d1e5f0\",\n            \"#92c5de\",\n            \"#4393c3\",\n            \"#2166ac\",\n            \"#053061\",\n        ],\n        reds: [\n            \"#fff5f0\",\n            \"#fee0d2\",\n            \"#fcbba1\",\n            \"#fc9272\",\n            \"#fb6a4a\",\n            \"#ef3b2c\",\n            \"#cb181d\",\n            \"#a50f15\",\n            \"#67000d\",\n        ],\n    };\n    const stops = paletteStops[palette] || paletteStops.reds;\n    return colormap.endsWith(\"_r\") ? [...stops].reverse() : stops;\n}\n\nfunction renderColorScaleHtml(stretch) {\n    if (!stretch) {\n        return \"<span>No stretch</span>\";\n    }\n    const decoded = decodeURIComponent(stretch);\n    const colormapMatch = decoded.match(/colormap=([^&]+)/);\n    const rangeMatch = decoded.match(/stretch_range=\\[([^\\]]+)\\]/);\n    const colormap = colormapMatch ? colormapMatch[1] : \"\";\n    let min = \"min\";\n    let max = \"max\";\n    if (rangeMatch) {\n        const parts = rangeMatch[1].split(\",\").map((value) => Number(value.trim()));\n        if (parts.length >= 2) {\n            min = parts[0].toFixed(1);\n            max = parts[1].toFixed(1);\n        }\n    }\n    const stops = getColorStops(colormap);\n    const gradient = `linear-gradient(90deg, ${stops.join(\", \")})`;\n    return `\n      <div style=\"display:flex; align-items:center; height:100%; gap:6px; font-variant-numeric:tabular-nums;\">\n        <span>${min}</span>\n        <div style=\"width:72px; height:8px; border-radius:999px; background:${gradient};\"></div>\n        <span>${max}</span>\n      </div>\n    `;\n}\n\nfunction refreshColorScale(stretch) {\n    const scale = document.getElementById(\"map-colorscale\");\n    if (!scale) {\n        return;\n    }\n    scale.innerHTML = renderColorScaleHtml(stretch);\n}\n// EXTERNAL:terracotta_dataset_utilities.js\nfunction buildDatasetId(params) {\n    const datasetFamily = params?.datasetFamily || \"grouped_metric\";\n    const { startDate, endDate } = resolveDatasetDates(datasetFamily);\n    const timeSuffix =\n        params.timeFilter && params.timeFilter !== \"None\" ? `_${params.timeFilter}` : \"\";\n\n    if (datasetFamily === \"metric\") {\n        const aggDays = String(params?.aggDays || \"7\");\n        const { truth, category } = splitProduct(params?.product);\n        return (\n            [\n                \"metric\",\n                aggDays,\n                endDate,\n                params.forecast,\n                params.grid,\n                \"lsm\",\n                params.metric,\n                \"global\",\n                \"None\",\n                \"True\",\n                startDate,\n                params.timeGrouping,\n                truth,\n                category,\n            ].join(\"_\") + timeSuffix\n        );\n    }\n\n    return (\n        `grouped_metric_${endDate}_` +\n        `${params.forecast}_${params.grid}_${params.lead}_lsm_${params.metric}_` +\n        `${params.region}_True_${startDate}_${params.timeGrouping}_${params.product}` +\n        timeSuffix\n    );\n}\n\nfunction resolveDatasetDates(datasetFamily) {\n    if (datasetFamily === \"metric\") {\n        return { startDate: \"1998-01-01\", endDate: \"2024-12-31\" };\n    }\n    return { startDate: \"2016-01-01\", endDate: \"2022-12-31\" };\n}\n\nfunction splitProduct(product) {\n    const raw = String(product || \"\");\n    const firstUnderscore = raw.indexOf(\"_\");\n    if (firstUnderscore > 0 && firstUnderscore < raw.length - 1) {\n        return {\n            truth: raw.slice(0, firstUnderscore),\n            category: raw.slice(firstUnderscore + 1),\n        };\n    }\n    return { truth: \"era5\", category: raw || \"precip\" };\n}\n\nfunction extractPercentileBounds(metadata) {\n    const percentiles = metadata?.percentiles || [];\n    if (percentiles.length < 95) {\n        return null;\n    }\n    return [percentiles[4], percentiles[94]];\n}\n\nfunction buildStretchFromBounds(colorMin, colorMax, metric, product) {\n    let colormap = \"reds\";\n    if (metric === \"bias\") {\n        if (Math.abs(colorMin) > colorMax) {\n            colorMax = Math.abs(colorMin);\n        } else {\n            colorMin = colorMax * -1;\n        }\n        colormap = product === \"era5_tmp2m\" ? \"rdbu_r\" : \"brbg\";\n    } else if (metric === \"acc\") {\n        colorMin = -1;\n        colorMax = 1;\n        colormap = \"rdbu\";\n    } else if (metric === \"seeps\") {\n        colorMin = 0;\n        colorMax = 2.0;\n        colormap = \"reds\";\n    }\n\n    return `colormap=${colormap}&stretch_range=[${colorMin},${colorMax}]`;\n}\n\nfunction computeStretch(metadata, metric, product) {\n    const bounds = extractPercentileBounds(metadata);\n    if (!bounds) {\n        return \"\";\n    }\n    return buildStretchFromBounds(bounds[0], bounds[1], metric, product);\n}\n\nfunction computeSharedStretchFromMetadata(metadataList, metric, product) {\n    const bounds = (metadataList || [])\n        .map((metadata) => extractPercentileBounds(metadata))\n        .filter((item) => Array.isArray(item));\n    if (!bounds.length) {\n        return \"\";\n    }\n    const colorMin = Math.min(...bounds.map((item) => item[0]));\n    const colorMax = Math.max(...bounds.map((item) => item[1]));\n    return buildStretchFromBounds(colorMin, colorMax, metric, product);\n}\n\nasync function fetchMetadata(params, signal) {\n    const datasetId = buildDatasetId(params);\n    const url = `${TERRACOTTA_BASE_URL}/metadata/${encodeURIComponent(datasetId)}`;\n    const response = await fetch(url, signal ? { signal } : undefined);\n    if (!response.ok) {\n        const error = new Error(`Metadata request failed (${response.status})`);\n        error.status = response.status;\n        throw error;\n    }\n    return response.json();\n}\n\nasync function fetchStretch(params, signal) {\n    const metadata = await fetchMetadata(params, signal);\n    return computeStretch(metadata, params.metric, params.product);\n}\n\nfunction buildTileUrl(params, stretch) {\n    const datasetId = buildDatasetId(params);\n    const base = `${TERRACOTTA_BASE_URL}/singleband/${encodeURIComponent(datasetId)}/{z}/{x}/{y}.png`;\n    if (!stretch) {\n        return { datasetId, tileUrl: base };\n    }\n    const query = encodeURIComponent(stretch)\n        .replace(/%26/g, \"&\")\n        .replace(/%3D/g, \"=\");\n    return { datasetId, tileUrl: `${base}?${query}` };\n}\n// EXTERNAL:maplibre-singlemap-orchestration.js\n\nfunction getPanelRoot() {\n    return (\n        document.querySelector(\"#panel-content\") ||\n        document.querySelector(\".panel-content\") ||\n        document.querySelector(\".panel-content--no-padding\") ||\n        document.querySelector(\".panel-container\") ||\n        document.body\n    );\n}\n\nfunction getOrCreateHostContainer() {\n    const existing = document.getElementById(MAP_CONTAINER_ID);\n    if (existing) {\n        return existing;\n    }\n    const host = document.createElement(\"div\");\n    host.id = MAP_CONTAINER_ID;\n    host.className = MAP_CONTAINER_ITEM_CLASS;\n    getPanelRoot().appendChild(host);\n    return host;\n}\n\nasync function initCurrentMapPage() {\n    const container = injectContainerAndStyles();\n    try {\n        await loadMaplibre();\n    } catch (error) {\n        console.error(\"MapLibre failed to load.\", error);\n        return;\n    }\n\n    if (!getMaplibreGlobal()) {\n        console.error(\"MapLibre is unavailable after load.\");\n        return;\n    }\n    if (!window.maplibregl && getMaplibreGlobal()) {\n        window.maplibregl = getMaplibreGlobal();\n    }\n\n    const params = {\n        ...VARS,\n        region: resolveRegion(VARS.forecast),\n    };\n\n    let stretch = \"\";\n    try {\n        stretch = await fetchStretch(params);\n    } catch (error) {\n        console.error(\"Failed to fetch stretch\", error);\n    }\n    refreshColorScale(stretch);\n\n    const { datasetId, tileUrl } = buildTileUrl(params, stretch);\n    let baseStyle = null;\n    try {\n        baseStyle = await fetchPreparedStyle(DEFAULT_FLAVOR);\n    } catch (error) {\n        console.error(\"Failed to fetch prepared style\", error);\n        return;\n    }\n\n    const existingRuntime = window.__grafanaMaplibre;\n    if (existingRuntime?.pollHandle) {\n        window.clearInterval(existingRuntime.pollHandle);\n    }\n    if (existingRuntime && existingRuntime.map) {\n        try {\n            existingRuntime.map.remove();\n        } catch (error) {\n            console.warn(\"Failed to remove existing map\", error);\n        }\n    }\n\n    const map = createSingleMapInstance(container, baseStyle);\n\n    window.__grafanaMaplibre = {\n        map,\n        datasetId,\n        tileUrl,\n        stretch,\n        params,\n        rasterSlot: 0,\n        rasterSwapToken: 0,\n        ready: false,\n    };\n\n    map.on(\"load\", () => {\n        window.__grafanaMaplibre.ready = true;\n        applyBoundaryContrastOverrides(map);\n        setRasterLayer(map, tileUrl, 0, TERRACOTTA_OPACITY);\n        removeRasterSlot(map, 1);\n    });\n\n    let pendingVars = null;\n    let pendingSince = 0;\n    let refreshToken = 0;\n\n    window.__grafanaMaplibre.pollHandle = window.setInterval(async () => {\n        if (!window.__grafanaMaplibre?.ready) {\n            return;\n        }\n\n        const observedVars = readVars();\n        const observedSig = JSON.stringify(observedVars);\n        const currentSig = JSON.stringify(VARS);\n        if (observedSig === currentSig) {\n            pendingVars = null;\n            pendingSince = 0;\n            return;\n        }\n\n        if (!pendingVars || JSON.stringify(pendingVars) !== observedSig) {\n            pendingVars = observedVars;\n            pendingSince = Date.now();\n            return;\n        }\n\n        if (Date.now() - pendingSince < VAR_STABILIZE_MS) {\n            return;\n        }\n\n        VARS = pendingVars;\n        pendingVars = null;\n        pendingSince = 0;\n        const nextParams = {\n            ...VARS,\n            region: resolveRegion(VARS.forecast),\n        };\n\n        if (stretchRequestController) {\n            stretchRequestController.abort();\n        }\n        stretchRequestController = new AbortController();\n        const token = ++refreshToken;\n\n        let nextStretch = \"\";\n        try {\n            nextStretch = await fetchStretch(\n                nextParams,\n                stretchRequestController.signal\n            );\n        } catch (error) {\n            if (error?.name === \"AbortError\") {\n                return;\n            }\n            console.error(\"Failed to fetch stretch\", error);\n        }\n        if (token !== refreshToken) {\n            return;\n        }\n\n        const next = buildTileUrl(nextParams, nextStretch);\n        if (nextStretch !== window.__grafanaMaplibre.stretch) {\n            refreshColorScale(nextStretch);\n        }\n\n        if (next.tileUrl !== window.__grafanaMaplibre.tileUrl) {\n            await swapRasterLayer(window.__grafanaMaplibre, next.tileUrl);\n        }\n\n        window.__grafanaMaplibre.datasetId = next.datasetId;\n        window.__grafanaMaplibre.tileUrl = next.tileUrl;\n        window.__grafanaMaplibre.stretch = nextStretch;\n        window.__grafanaMaplibre.params = nextParams;\n    }, POLL_INTERVAL_MS);\n}\n// EXTERNAL:maplibre-multimap-orchestration.js\n\nfunction ensureRuntimeContainer() {\n    const existingRuntime = window.__grafanaMaplibreMultimap;\n    if (existingRuntime?.pollHandle) {\n        window.clearInterval(existingRuntime.pollHandle);\n    }\n    if (existingRuntime?.cells) {\n        existingRuntime.cells.forEach((cellRuntime) => {\n            if (cellRuntime?.map) {\n                try {\n                    cellRuntime.map.remove();\n                } catch (error) {\n                    console.warn(\"Failed to remove existing multimap map\", error);\n                }\n            }\n        });\n    }\n}\n\nfunction applyManualSync(maps) {\n    let syncing = false;\n    const syncFrom = (sourceMap) => {\n        if (syncing) {\n            return;\n        }\n        syncing = true;\n        const center = sourceMap.getCenter();\n        const zoom = sourceMap.getZoom();\n        const bearing = sourceMap.getBearing();\n        const pitch = sourceMap.getPitch();\n\n        maps.forEach((map) => {\n            if (map === sourceMap) {\n                return;\n            }\n            map.jumpTo({ center, zoom, bearing, pitch });\n        });\n        syncing = false;\n    };\n\n    maps.forEach((map) => {\n        map.on(\"moveend\", () => syncFrom(map));\n        map.on(\"zoomend\", () => syncFrom(map));\n        map.on(\"dragend\", () => syncFrom(map));\n    });\n}\n\nfunction loadSyncMovePlugin() {\n    if (window.syncMaps && typeof window.syncMaps === \"function\") {\n        return Promise.resolve();\n    }\n    if (syncMoveReady) {\n        return syncMoveReady;\n    }\n\n    syncMoveReady = new Promise((resolve) => {\n        const script = document.createElement(\"script\");\n        script.src = \"https://unpkg.com/mapbox-gl-sync-move@0.3.1/index.js\";\n        script.onload = () => resolve();\n        script.onerror = () => resolve();\n        document.head.appendChild(script);\n    });\n\n    return syncMoveReady;\n}\n\nasync function synchronizeMaps(cellRuntimes) {\n    const maps = cellRuntimes.map((runtime) => runtime.map).filter(Boolean);\n    if (maps.length < 2) {\n        return;\n    }\n\n    await loadSyncMovePlugin();\n    if (window.syncMaps && typeof window.syncMaps === \"function\") {\n        try {\n            window.syncMaps(...maps);\n            return;\n        } catch (error) {\n            console.warn(\"syncMaps plugin failed, using fallback sync\", error);\n        }\n    }\n    applyManualSync(maps);\n}\n\nfunction buildCellParams(vars, cellDef) {\n    return {\n        forecast: vars.forecast,\n        grid: vars.grid,\n        metric: vars.metric,\n        product: cellDef.productValue,\n        lead: `week${cellDef.week}`,\n        timeGrouping: vars.timeGrouping,\n        timeFilter: vars.timeFilter,\n        region: resolveRegion(vars.forecast),\n    };\n}\n\nfunction setProductRowVisibility(productKey, visible) {\n    const row = document.getElementById(`bt-multimap-row-${productKey}`);\n    if (!row) {\n        return;\n    }\n    row.style.display = visible ? \"\" : \"none\";\n}\n\nasync function refreshAllCells(runtime, vars) {\n    if (stretchRequestController) {\n        stretchRequestController.abort();\n    }\n    stretchRequestController = new AbortController();\n    const signal = stretchRequestController.signal;\n    const token = (runtime.refreshToken || 0) + 1;\n    runtime.refreshToken = token;\n\n    const metadataResults = await Promise.all(\n        runtime.cells.map(async (cellRuntime) => {\n            const nextParams = buildCellParams(vars, cellRuntime.def);\n            let metadata = null;\n            try {\n                metadata = await fetchMetadata(nextParams, signal);\n            } catch (error) {\n                if (error?.name !== \"AbortError\" && error?.status !== 404) {\n                    console.error(\"Failed to fetch metadata\", error);\n                }\n            }\n            return {\n                key: cellRuntime.def.key,\n                productKey: cellRuntime.def.productKey,\n                params: nextParams,\n                metadata,\n            };\n        })\n    );\n\n    if (runtime.refreshToken !== token) {\n        return;\n    }\n\n    const scaleByProduct = {};\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const leadMetadata = metadataResults\n            .filter(\n                (result) =>\n                    result.productKey === product.key && result.metadata !== null\n            )\n            .map((result) => result.metadata);\n        scaleByProduct[product.key] = computeSharedStretchFromMetadata(\n            leadMetadata,\n            vars.metric,\n            product.product\n        );\n    });\n\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const hasStretch = Boolean(scaleByProduct[product.key]);\n        setProductRowVisibility(product.key, hasStretch);\n        const scaleMarkup = renderColorScaleHtml(scaleByProduct[product.key] || \"\");\n        const rowScaleEl = document.getElementById(\n            `bt-multimap-row-scale-${product.key}`\n        );\n        if (rowScaleEl) {\n            rowScaleEl.innerHTML = scaleMarkup;\n        }\n        const scaleEls = document.querySelectorAll(\n            `.bt-multimap-map-scale[data-product-key=\"${product.key}\"]`\n        );\n        scaleEls.forEach((scaleEl) => {\n            scaleEl.innerHTML = scaleMarkup;\n        });\n    });\n\n    const results = metadataResults.map((result) => {\n        const sharedStretch = scaleByProduct[result.productKey] || \"\";\n        if (!sharedStretch) {\n            return {\n                ...result,\n                stretch: \"\",\n                datasetId: buildDatasetId(result.params),\n                tileUrl: \"\",\n            };\n        }\n        if (result.metadata === null) {\n            return {\n                ...result,\n                stretch: sharedStretch,\n                datasetId: buildDatasetId(result.params),\n                tileUrl: \"\",\n            };\n        }\n        const next = buildTileUrl(result.params, sharedStretch);\n        return {\n            ...result,\n            stretch: sharedStretch,\n            datasetId: next.datasetId,\n            tileUrl: next.tileUrl,\n        };\n    });\n\n    for (const result of results) {\n        const cellRuntime = runtime.cellsByKey.get(result.key);\n        if (!cellRuntime) {\n            continue;\n        }\n\n        const previousTileUrl = cellRuntime.tileUrl;\n        cellRuntime.params = result.params;\n        cellRuntime.stretch = result.stretch;\n        cellRuntime.datasetId = result.datasetId;\n        cellRuntime.tileUrl = result.tileUrl;\n\n        if (!cellRuntime.ready) {\n            continue;\n        }\n\n        if (!result.tileUrl) {\n            removeRasterSlot(cellRuntime.map, 0);\n            removeRasterSlot(cellRuntime.map, 1);\n            continue;\n        }\n\n        if (!previousTileUrl) {\n            setRasterLayer(cellRuntime.map, result.tileUrl, 0, TERRACOTTA_OPACITY);\n            removeRasterSlot(cellRuntime.map, 1);\n            continue;\n        }\n\n        if (previousTileUrl !== result.tileUrl) {\n            await swapRasterLayer(cellRuntime, result.tileUrl);\n        }\n    }\n}\n\nasync function initCurrentMultimapPage() {\n    const leadWeeks = getLeadWeeks(VARS.maxLead);\n    buildMultimapLayout(leadWeeks);\n\n    try {\n        await loadMaplibre();\n    } catch (error) {\n        console.error(\"MapLibre failed to load.\", error);\n        return;\n    }\n\n    if (!getMaplibreGlobal()) {\n        console.error(\"MapLibre is unavailable after load.\");\n        return;\n    }\n    if (!window.maplibregl && getMaplibreGlobal()) {\n        window.maplibregl = getMaplibreGlobal();\n    }\n\n    let baseStyle = null;\n    try {\n        baseStyle = await fetchPreparedStyle(DEFAULT_FLAVOR);\n    } catch (error) {\n        console.error(\"Failed to fetch prepared style\", error);\n        return;\n    }\n\n    ensureRuntimeContainer();\n\n    const defs = getCellDefinitions(leadWeeks);\n    const cells = defs\n        .map((def) => {\n            const container = document.getElementById(def.containerId);\n            if (!container) {\n                return null;\n            }\n            const map = createSingleMapInstance(container, baseStyle);\n            const cellRuntime = {\n                def,\n                map,\n                ready: false,\n                datasetId: \"\",\n                tileUrl: \"\",\n                stretch: \"\",\n                params: null,\n                rasterSlot: 0,\n                rasterSwapToken: 0,\n            };\n            map.on(\"load\", () => {\n                cellRuntime.ready = true;\n                applyBoundaryContrastOverrides(map);\n                if (cellRuntime.tileUrl) {\n                    setRasterLayer(map, cellRuntime.tileUrl, 0, TERRACOTTA_OPACITY);\n                    removeRasterSlot(map, 1);\n                }\n            });\n            return cellRuntime;\n        })\n        .filter(Boolean);\n\n    const cellsByKey = new Map(cells.map((cell) => [cell.def.key, cell]));\n\n    window.__grafanaMaplibreMultimap = {\n        cells,\n        cellsByKey,\n        refreshToken: 0,\n        pollHandle: null,\n    };\n\n    synchronizeMaps(cells);\n    await refreshAllCells(window.__grafanaMaplibreMultimap, VARS);\n\n    let pendingVars = null;\n    let pendingSince = 0;\n\n    window.__grafanaMaplibreMultimap.pollHandle = window.setInterval(async () => {\n        const observedVars = readVars();\n        const observedSig = JSON.stringify(observedVars);\n        const currentSig = JSON.stringify(VARS);\n        if (observedSig === currentSig) {\n            pendingVars = null;\n            pendingSince = 0;\n            return;\n        }\n\n        if (!pendingVars || JSON.stringify(pendingVars) !== observedSig) {\n            pendingVars = observedVars;\n            pendingSince = Date.now();\n            return;\n        }\n\n        if (Date.now() - pendingSince < VAR_STABILIZE_MS) {\n            return;\n        }\n\n        VARS = pendingVars;\n        pendingVars = null;\n        pendingSince = 0;\n\n        await refreshAllCells(window.__grafanaMaplibreMultimap, VARS);\n    }, POLL_INTERVAL_MS);\n}\n// EXTERNAL:maplibre-multimap-layout.js\nfunction ensureMultimapStyles() {\n    if (document.getElementById(\"bt-multimap-styles\")) {\n        return;\n    }\n    const style = document.createElement(\"style\");\n    style.id = \"bt-multimap-styles\";\n    style.textContent = `\n      .bt-multimap-root {\n        display:grid;\n        gap:18px;\n        width:100%;\n        font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n      }\n      .bt-multimap-row {\n        display:grid;\n        gap:10px;\n      }\n      .bt-multimap-row-header {\n        display:flex;\n        align-items:center;\n        justify-content:space-between;\n        gap:12px;\n      }\n      .bt-multimap-row-title {\n        color:#0c1f2e;\n        font-size:16px;\n        font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n        font-weight:400;\n        line-height:1.2;\n      }\n      .bt-multimap-row-scale {\n        background:rgba(245, 243, 239, 0.75);\n        color:#0c1f2e;\n        padding:4px 8px;\n        border-radius:999px;\n        border:1px solid rgba(12, 31, 46, 0.18);\n        font-size:11px;\n        line-height:1;\n        min-height:24px;\n        display:flex;\n        align-items:center;\n        justify-content:center;\n        white-space:nowrap;\n      }\n      .bt-multimap-map-scale {\n        position:absolute;\n        left:10px;\n        bottom:10px;\n        z-index:4;\n        display:none;\n        pointer-events:none;\n        background:rgba(245, 243, 239, 0.96);\n        color:#0c1f2e;\n        padding:4px 8px;\n        border-radius:10px;\n        border:1px solid rgba(12, 31, 46, 0.18);\n        font-size:11px;\n        line-height:1.2;\n        min-height:22px;\n        align-items:center;\n        justify-content:center;\n        white-space:nowrap;\n      }\n      .bt-multimap-map:fullscreen .bt-multimap-map-scale,\n      .bt-multimap-map:-webkit-full-screen .bt-multimap-map-scale {\n        display:flex;\n      }\n      @media (max-width: 720px) {\n        .bt-multimap-row-header {\n          flex-wrap:wrap;\n          row-gap:8px;\n        }\n      }\n      .bt-multimap-grid {\n        display:grid;\n        gap:12px;\n        grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));\n      }\n      .bt-multimap-cell {\n        display:grid;\n        gap:6px;\n      }\n      .bt-multimap-cell-title {\n        font-size:12px;\n        color:#0c1f2e;\n        font-weight:600;\n      }\n      .bt-multimap-map {\n        position:relative;\n        width:100%;\n        height:280px;\n        border-radius:12px;\n        overflow:hidden;\n        box-shadow:0 10px 28px rgba(8, 16, 28, 0.2);\n        border:1px solid rgba(12, 31, 46, 0.2);\n        background:#0b1220;\n      }\n      .maplibregl-canvas {\n        width:100% !important;\n        height:100% !important;\n      }\n      @media (max-width: 900px) {\n        .bt-multimap-map {\n          height:240px;\n        }\n      }\n    `;\n    document.head.appendChild(style);\n\n    const css = document.createElement(\"link\");\n    css.rel = \"stylesheet\";\n    css.href = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css\";\n    document.head.appendChild(css);\n}\n\nfunction buildMultimapLayout(leadWeeks) {\n    ensureMultimapStyles();\n    const host = getOrCreateHostContainer();\n    const rootId = \"bt-multimap-root\";\n    const existing = document.getElementById(rootId);\n    if (existing) {\n        return existing;\n    }\n\n    const root = document.createElement(\"div\");\n    root.id = rootId;\n    root.className = \"bt-multimap-root\";\n\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const row = document.createElement(\"div\");\n        row.className = \"bt-multimap-row\";\n        row.id = `bt-multimap-row-${product.key}`;\n\n        const header = document.createElement(\"div\");\n        header.className = \"bt-multimap-row-header\";\n\n        const rowTitle = document.createElement(\"div\");\n        rowTitle.className = \"bt-multimap-row-title\";\n        rowTitle.textContent = product.label;\n        header.appendChild(rowTitle);\n\n        const rowScale = document.createElement(\"div\");\n        rowScale.className = \"bt-multimap-row-scale\";\n        rowScale.id = `bt-multimap-row-scale-${product.key}`;\n        rowScale.innerHTML = \"Loading...\";\n        header.appendChild(rowScale);\n\n        row.appendChild(header);\n\n        const grid = document.createElement(\"div\");\n        grid.className = \"bt-multimap-grid\";\n\n        leadWeeks.forEach((week) => {\n            const cell = document.createElement(\"div\");\n            cell.className = \"bt-multimap-cell\";\n\n            const title = document.createElement(\"div\");\n            title.className = \"bt-multimap-cell-title\";\n            title.textContent = `Week ${week}`;\n            cell.appendChild(title);\n\n            const mapContainer = document.createElement(\"div\");\n            mapContainer.className = \"bt-multimap-map\";\n            mapContainer.id = `bt-multimap-${product.key}-week${week}`;\n\n            const scale = document.createElement(\"div\");\n            scale.className = \"bt-multimap-map-scale\";\n            scale.id = `bt-multimap-scale-${product.key}-week${week}`;\n            scale.dataset.productKey = product.key;\n            scale.innerHTML = \"Loading...\";\n            mapContainer.appendChild(scale);\n\n            cell.appendChild(mapContainer);\n\n            grid.appendChild(cell);\n        });\n\n        row.appendChild(grid);\n        root.appendChild(row);\n    });\n\n    host.appendChild(root);\n    return root;\n}\n\nfunction getCellDefinitions(leadWeeks) {\n    const cells = [];\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        leadWeeks.forEach((week) => {\n            cells.push({\n                key: `${product.key}-week${week}`,\n                productKey: product.key,\n                productValue: product.product,\n                week,\n                containerId: `bt-multimap-${product.key}-week${week}`,\n            });\n        });\n    });\n    return cells;\n}\n// EXTERNAL({\"panel_id\":\"multimap-forecast-evaluation\",\"key\":\"call-function\"}):bfd145p7u3jlse-multimap-forecast-evaluation-call-function.js\n(() => {\n    function runCurrentMultimapPanel() {\n        return initCurrentMultimapPage();\n    }\n\n    runCurrentMultimapPanel();\n})();\n",
        "content": "<div id=\"map-container\" style=\"height:900px\" />",
        "contentPartials": [],
        "defaultContent": "",
        "editor": {
          "format": "auto",
          "language": "html"
        },
        "editors": [
          "afterRender"
        ],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "data",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "6.2.0",
      "targets": [
        {
          "datasource": {
            "type": "datasource",
            "uid": "grafana"
          },
          "path": "img",
          "queryType": "list",
          "refId": "A"
        }
      ],
      "title": "",
      "transparent": true,
      "type": "marcusolsson-dynamictext-panel"
    }
  ],
  "preload": false,
  "refresh": "",
  "schemaVersion": 40,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "text": [
            "SOM",
            "KEN"
          ],
          "value": [
            "SOM",
            "KEN"
          ]
        },
        "hide": 2,
        "includeAll": false,
        "label": "Countries",
        "multi": true,
        "name": "countries",
        "options": [
          {
            "selected": false,
            "text": "Algeria",
            "value": "DZA"
          },
          {
            "selected": false,
            "text": "Angola",
            "value": "AGO"
          },
          {
            "selected": false,
            "text": "Benin",
            "value": "BEN"
          },
          {
            "selected": false,
            "text": "Botswana",
            "value": "BWA"
          },
          {
            "selected": false,
            "text": "Burkina Faso",
            "value": "BFA"
          },
          {
            "selected": false,
            "text": "Burundi",
            "value": "BDI"
          },
          {
            "selected": false,
            "text": "Cabo Verde",
            "value": "CPV"
          },
          {
            "selected": false,
            "text": "Cameroon",
            "value": "CMR"
          },
          {
            "selected": false,
            "text": "Central African Republic",
            "value": "CAF"
          },
          {
            "selected": false,
            "text": "Chad",
            "value": "TCD"
          },
          {
            "selected": false,
            "text": "Comoros",
            "value": "COM"
          },
          {
            "selected": false,
            "text": "Congo (Republic)",
            "value": "COG"
          },
          {
            "selected": false,
            "text": "Congo (DRC)",
            "value": "COD"
          },
          {
            "selected": false,
            "text": "Djibouti",
            "value": "DJI"
          },
          {
            "selected": false,
            "text": "Egypt",
            "value": "EGY"
          },
          {
            "selected": false,
            "text": "Equatorial Guinea",
            "value": "GNQ"
          },
          {
            "selected": false,
            "text": "Eritrea",
            "value": "ERI"
          },
          {
            "selected": false,
            "text": "Eswatini",
            "value": "SWZ"
          },
          {
            "selected": false,
            "text": "Ethiopia",
            "value": "ETH"
          },
          {
            "selected": false,
            "text": "Gabon",
            "value": "GAB"
          },
          {
            "selected": false,
            "text": "Gambia",
            "value": "GMB"
          },
          {
            "selected": false,
            "text": "Ghana",
            "value": "GHA"
          },
          {
            "selected": false,
            "text": "Guinea",
            "value": "GIN"
          },
          {
            "selected": false,
            "text": "Guinea-Bissau",
            "value": "GNB"
          },
          {
            "selected": false,
            "text": "Cote d'Ivoire",
            "value": "CIV"
          },
          {
            "selected": true,
            "text": "Kenya",
            "value": "KEN"
          },
          {
            "selected": false,
            "text": "Lesotho",
            "value": "LSO"
          },
          {
            "selected": false,
            "text": "Liberia",
            "value": "LBR"
          },
          {
            "selected": false,
            "text": "Libya",
            "value": "LBY"
          },
          {
            "selected": false,
            "text": "Madagascar",
            "value": "MDG"
          },
          {
            "selected": false,
            "text": "Malawi",
            "value": "MWI"
          },
          {
            "selected": false,
            "text": "Mali",
            "value": "MLI"
          },
          {
            "selected": false,
            "text": "Mauritania",
            "value": "MRT"
          },
          {
            "selected": false,
            "text": "Mauritius",
            "value": "MUS"
          },
          {
            "selected": false,
            "text": "Morocco",
            "value": "MAR"
          },
          {
            "selected": false,
            "text": "Mozambique",
            "value": "MOZ"
          },
          {
            "selected": false,
            "text": "Namibia",
            "value": "NAM"
          },
          {
            "selected": false,
            "text": "Niger",
            "value": "NER"
          },
          {
            "selected": false,
            "text": "Nigeria",
            "value": "NGA"
          },
          {
            "selected": false,
            "text": "Rwanda",
            "value": "RWA"
          },
          {
            "selected": false,
            "text": "Sao Tome and Principe",
            "value": "STP"
          },
          {
            "selected": false,
            "text": "Senegal",
            "value": "SEN"
          },
          {
            "selected": false,
            "text": "Seychelles",
            "value": "SYC"
          },
          {
            "selected": false,
            "text": "Sierra Leone",
            "value": "SLE"
          },
          {
            "selected": true,
            "text": "Somalia",
            "value": "SOM"
          },
          {
            "selected": false,
            "text": "South Africa",
            "value": "ZAF"
          },
          {
            "selected": false,
            "text": "South Sudan",
            "value": "SSD"
          },
          {
            "selected": false,
            "text": "Sudan",
            "value": "SDN"
          },
          {
            "selected": false,
            "text": "Tanzania",
            "value": "TZA"
          },
          {
            "selected": false,
            "text": "Togo",
            "value": "TGO"
          },
          {
            "selected": false,
            "text": "Tunisia",
            "value": "TUN"
          },
          {
            "selected": false,
            "text": "Uganda",
            "value": "UGA"
          },
          {
            "selected": false,
            "text": "Zambia",
            "value": "ZMB"
          },
          {
            "selected": false,
            "text": "Zimbabwe",
            "value": "ZWE"
          }
        ],
        "query": "Algeria : DZA, Angola : AGO, Benin : BEN, Botswana : BWA, Burkina Faso : BFA, Burundi : BDI, Cabo Verde : CPV, Cameroon : CMR, Central African Republic : CAF, Chad : TCD, Comoros : COM, Congo (Republic) : COG, Congo (DRC) : COD, Djibouti : DJI, Egypt : EGY, Equatorial Guinea : GNQ, Eritrea : ERI, Eswatini : SWZ, Ethiopia : ETH, Gabon : GAB, Gambia : GMB, Ghana : GHA, Guinea : GIN, Guinea-Bissau : GNB, Cote d'Ivoire : CIV, Kenya : KEN, Lesotho : LSO, Liberia : LBR, Libya : LBY, Madagascar : MDG, Malawi : MWI, Mali : MLI, Mauritania : MRT, Mauritius : MUS, Morocco : MAR, Mozambique : MOZ, Namibia : NAM, Niger : NER, Nigeria : NGA, Rwanda : RWA, Sao Tome and Principe : STP, Senegal : SEN, Seychelles : SYC, Sierra Leone : SLE, Somalia : SOM, South Africa : ZAF, South Sudan : SSD, Sudan : SDN, Tanzania : TZA, Togo : TGO, Tunisia : TUN, Uganda : UGA, Zambia : ZMB, Zimbabwe : ZWE",
        "type": "custom"
      },
      {
        "current": {
          "text": "ADM1",
          "value": "ADM1"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Geo Level",
        "name": "geo_level",
        "options": [
          {
            "selected": true,
            "text": "ADM1",
            "value": "ADM1"
          },
          {
            "selected": false,
            "text": "ADM2",
            "value": "ADM2"
          },
          {
            "selected": false,
            "text": "ADM3",
            "value": "ADM3"
          }
        ],
        "query": "ADM1, ADM2, ADM3",
        "type": "custom"
      },
      {
        "current": {
          "text": "ecmwf_ifs_er",
          "value": "ecmwf_ifs_er"
        },
        "includeAll": false,
        "label": "Forecast",
        "name": "forecast",
        "options": [
          {
            "selected": false,
            "text": "AI-Enhanced NWP",
            "value": "salient"
          },
          {
            "selected": true,
            "text": "ECMWF IFS ER",
            "value": "ecmwf_ifs_er"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER Debiased",
            "value": "ecmwf_ifs_er_debiased"
          },
          {
            "selected": false,
            "text": "Clim 1985-2014",
            "value": "climatology_2015"
          },
          {
            "selected": false,
            "text": "Clim + Trend",
            "value": "climatology_trend_2015"
          },
          {
            "selected": false,
            "text": "Clim Rolling",
            "value": "climatology_rolling"
          },
          {
            "selected": false,
            "text": "FuXi",
            "value": "fuxi"
          },
          {
            "selected": false,
            "text": "GraphCast",
            "value": "graphcast"
          },
          {
            "selected": false,
            "text": "GenCast",
            "value": "gencast"
          }
        ],
        "query": "AI-Enhanced NWP : salient, ECMWF IFS ER : ecmwf_ifs_er, ECMWF IFS ER Debiased : ecmwf_ifs_er_debiased, Clim 1985-2014 : climatology_2015, Clim + Trend : climatology_trend_2015, Clim Rolling : climatology_rolling, FuXi : fuxi, GraphCast : graphcast, GenCast : gencast",
        "type": "custom"
      },
      {
        "current": {
          "text": "mae",
          "value": "mae"
        },
        "includeAll": false,
        "label": "Metric",
        "name": "metric",
        "options": [
          {
            "selected": true,
            "text": "MAE",
            "value": "mae"
          },
          {
            "selected": false,
            "text": "CRPS",
            "value": "crps"
          },
          {
            "selected": false,
            "text": "RMSE",
            "value": "rmse"
          },
          {
            "selected": false,
            "text": "ACC",
            "value": "acc"
          },
          {
            "selected": false,
            "text": "Bias",
            "value": "bias"
          },
          {
            "selected": false,
            "text": "SMAPE",
            "value": "smape"
          },
          {
            "selected": false,
            "text": "SEEPS",
            "value": "seeps"
          },
          {
            "selected": false,
            "text": "Heidke (1/5/10/20mm)",
            "value": "heidke-1-5-10-20"
          },
          {
            "selected": false,
            "text": "POD 1mm",
            "value": "pod-1"
          },
          {
            "selected": false,
            "text": "POD 5mm",
            "value": "pod-5"
          },
          {
            "selected": false,
            "text": "POD 10mm",
            "value": "pod-10"
          },
          {
            "selected": false,
            "text": "FAR 1mm",
            "value": "far-1"
          },
          {
            "selected": false,
            "text": "FAR 5mm",
            "value": "far-5"
          },
          {
            "selected": false,
            "text": "FAR 10mm",
            "value": "far-10"
          },
          {
            "selected": false,
            "text": "ETS 1mm",
            "value": "ets-1"
          },
          {
            "selected": false,
            "text": "ETS 5mm",
            "value": "ets-5"
          },
          {
            "selected": false,
            "text": "ETS 10mm",
            "value": "ets-10"
          }
        ],
        "query": "MAE : mae, CRPS : crps, RMSE : rmse, ACC : acc, Bias : bias, SMAPE : smape, SEEPS : seeps, Heidke (1/5/10/20mm) : heidke-1-5-10-20, POD 1mm : pod-1, POD 5mm : pod-5, POD 10mm : pod-10, FAR 1mm : far-1, FAR 5mm : far-5, FAR 10mm : far-10, ETS 1mm : ets-1, ETS 5mm : ets-5, ETS 10mm : ets-10",
        "type": "custom"
      },
      {
        "current": {
          "text": "week1",
          "value": "week1"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Lead",
        "name": "lead",
        "options": [
          {
            "selected": true,
            "text": "Week 1",
            "value": "week1"
          },
          {
            "selected": false,
            "text": "Week 2",
            "value": "week2"
          },
          {
            "selected": false,
            "text": "Week 3",
            "value": "week3"
          },
          {
            "selected": false,
            "text": "Week 4",
            "value": "week4"
          },
          {
            "selected": false,
            "text": "Week 5",
            "value": "week5"
          },
          {
            "selected": false,
            "text": "Week 6",
            "value": "week6"
          }
        ],
        "query": "Week 1 : week1, Week 2 : week2, Week 3 : week3, Week 4 : week4, Week 5 : week5, Week 6 : week6",
        "type": "custom"
      },
      {
        "current": {
          "text": "era5",
          "value": "era5"
        },
        "includeAll": false,
        "label": "Ground Truth",
        "name": "truth",
        "options": [
          {
            "selected": true,
            "text": "ERA5",
            "value": "era5"
          }
        ],
        "query": "ERA5 : era5",
        "type": "custom"
      },
      {
        "current": {
          "text": "global0_25",
          "value": "global0_25"
        },
        "includeAll": false,
        "label": "Grid",
        "name": "grid",
        "options": [
          {
            "selected": false,
            "text": "1.5",
            "value": "global1_5"
          },
          {
            "selected": true,
            "text": "0.25",
            "value": "global0_25"
          }
        ],
        "query": "1.5 : global1_5, 0.25 : global0_25",
        "type": "custom"
      },
      {
        "current": {
          "text": "africa",
          "value": "africa"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Region",
        "name": "region",
        "options": [
          {
            "selected": false,
            "text": "Global",
            "value": "global"
          },
          {
            "selected": true,
            "text": "Africa",
            "value": "africa"
          }
        ],
        "query": " Global : global, Africa : africa",
        "type": "custom"
      },
      {
        "current": {
          "text": "year",
          "value": "year"
        },
        "includeAll": false,
        "label": "Time Grouping",
        "name": "time_grouping",
        "options": [
          {
            "selected": false,
            "text": "None",
            "value": "None"
          },
          {
            "selected": false,
            "text": "Month of Year",
            "value": "month_of_year"
          },
          {
            "selected": true,
            "text": "Year",
            "value": "year"
          }
        ],
        "query": "None : None, Month of Year : month_of_year, Year : year",
        "type": "custom"
      },
      {
        "current": {
          "text": "select distinct time from \"6c89d88636ee3ea0507d7c5566df7dd9\"",
          "value": "select distinct time from \"6c89d88636ee3ea0507d7c5566df7dd9\""
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "2016",
          "value": "2016"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "${time_filter_filter_query:raw}",
        "includeAll": false,
        "label": "Time Filter",
        "name": "time_filter",
        "options": [],
        "query": "${time_filter_filter_query:raw}",
        "refresh": 1,
        "regex": "",
        "sort": 3,
        "type": "query"
      },
      {
        "current": {
          "text": "where time = 2016",
          "value": "where time = 2016"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "6c89d88636ee3ea0507d7c5566df7dd9",
          "value": "6c89d88636ee3ea0507d7c5566df7dd9"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "false",
          "value": "false"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Standardize Forecast Colors",
        "name": "standardize_forecast_colors",
        "options": [
          {
            "selected": true,
            "text": "False",
            "value": "false"
          }
        ],
        "query": "False : false",
        "type": "custom"
      },
      {
        "current": {
          "text": "false",
          "value": "false"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Standardize Lead Colors",
        "name": "standardize_lead_colors",
        "options": [
          {
            "selected": true,
            "text": "False",
            "value": "false"
          }
        ],
        "query": "False : false",
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {
    "hidden": true
  },
  "timezone": "utc",
  "title": "Forecast Evaluation Maps - multihorizon",
  "uid": "bfd145p7u3jlse",
  "version": 1,
  "weekStart": ""
}