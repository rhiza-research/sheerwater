{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "links": [],
  "panels": [
    {
      "datasource": {
        "type": "datasource",
        "uid": "grafana"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 25,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 9,
      "options": {
        "afterRender": "// EXTERNAL({\"panel_id\":\"multimap-forecast-evaluation\",\"key\":\"params\"}):bfd145p7u3jlse-multimap-forecast-evaluation-params.js\nconst PROTOMAPS_KEY = \"320f86609595a624\";\nconst BASE_STYLE_URL_TEMPLATE =\n    \"https://api.protomaps.com/styles/v5/{flavor}/{lang}.json?key={key}\";\nconst TERRACOTTA_BASE_URL = \"https://terracotta.shared.rhizaresearch.org\";\nconst MAP_CONTAINER_ITEM_CLASS = \"map-container\";\nconst MAP_CONTAINER_ID = \"map-container\";\nconst TERRACOTTA_LAYER_ID = \"terracotta-raster\";\nconst TERRACOTTA_OPACITY = 0.9;\nconst RASTER_CROSSFADE_MS = 0;\nconst RASTER_LOAD_TIMEOUT_MS = 1800;\nconst DEFAULT_FLAVOR = \"black\";\nconst BASE_STYLE_LANG = \"en\";\nconst ALLOWED_SOURCE_LAYERS = [\n    \"boundaries\",\n    \"earth\",\n    \"landcover\",\n    \"places\",\n    \"water\",\n];\nconst MANAGED_OVERLAY_GROUPS = [\n    { key: \"hydroFills\", type: \"fill\", sourceLayer: \"water\" },\n    { key: \"hydroLines\", type: \"line\", sourceLayer: \"water\" },\n    { key: \"adminLines\", type: \"line\", sourceLayer: \"boundaries\" },\n    {\n        key: \"adminBoundaryLabels\",\n        type: \"symbol\",\n        sourceLayer: \"boundaries\",\n    },\n    { key: \"adminAreaLabels\", type: \"symbol\", sourceLayer: \"places\" },\n];\nconst BOUNDARY_CONTRAST = {\n    lineStrokeColor: \"rgba(255,255,255,0.92)\",\n    lineStrokeOpacity: 0.95,\n    lineCasingColor: \"rgba(0,0,0,0.85)\",\n    lineCasingOpacity: 0.9,\n    lineCasingExtraWidth: 1.8,\n    labelTextColor: \"#ffffff\",\n    labelHaloColor: \"#000000\",\n    labelHaloWidth: 1.8,\n    labelHaloBlur: 0.3,\n};\nconst POLL_INTERVAL_MS = 300;\nconst VAR_STABILIZE_MS = 700;\nconst MULTIMAP_TIME_FILTER_OUTPUT_MODE = \"NUMBER\";\n\nconst MULTIMAP_PRODUCTS = [\n    { key: \"rain\", label: \"Precipitation\", product: \"era5_precip\" },\n    { key: \"temp\", label: \"Temperature\", product: \"era5_tmp2m\" },\n];\n\nconst replaceVariables =\n    typeof context !== \"undefined\" &&\n        context?.grafana?.replaceVariables &&\n        typeof context.grafana.replaceVariables === \"function\"\n        ? context.grafana.replaceVariables.bind(context.grafana)\n        : (value) => value;\n\nconst readVar = (name, fallback = \"\") => {\n    const token = `\\${${name}}`;\n    const value = replaceVariables(token);\n    if (value === token || value === undefined || value === null || value === \"\") {\n        return fallback;\n    }\n    return value;\n};\n\nconst readVars = () => ({\n    forecast: readVar(\"forecast\"),\n    grid: readVar(\"grid\"),\n    metric: readVar(\"metric\"),\n    timeGrouping: readVar(\"time_grouping\"),\n    timeFilter: readVar(\"time_filter\", \"None\"),\n    timeFilterOutputMode: MULTIMAP_TIME_FILTER_OUTPUT_MODE,\n    maxLead: Number(readVar(\"max_lead\", \"6\")) || 6,\n});\n\nfunction resolveRegion(forecast) {\n    return forecast === \"salient\" ? \"africa\" : \"global\";\n}\n\nfunction getLeadWeeks(maxLead) {\n    const safeMax = Math.max(1, Math.floor(Number(maxLead) || 1));\n    return Array.from({ length: safeMax }, (_, idx) => idx + 1);\n}\n\nlet VARS = readVars();\nlet stretchRequestController = null;\nlet maplibreReady = null;\nlet syncMoveReady = null;\n// EXTERNAL:maplibre-map-builder.js\nfunction buildStyleUrl(flavor) {\n    return BASE_STYLE_URL_TEMPLATE.replace(\"{flavor}\", flavor)\n        .replace(\"{lang}\", BASE_STYLE_LANG)\n        .replace(\"{key}\", PROTOMAPS_KEY);\n}\n\nasync function fetchPreparedStyle(flavor) {\n    const response = await fetch(buildStyleUrl(flavor));\n    if (!response.ok) {\n        throw new Error(`Style request failed (${response.status}).`);\n    }\n    const rawStyle = await response.json();\n    return prepareStyle(rawStyle);\n}\n\nfunction prepareStyle(styleJson) {\n    const allowedSourceLayers = new Set(ALLOWED_SOURCE_LAYERS);\n    const filteredLayers = (styleJson.layers || [])\n        .filter((layer) => {\n            const sourceLayer = layer[\"source-layer\"];\n            if (!sourceLayer) {\n                return true;\n            }\n            return (\n                allowedSourceLayers.size === 0 ||\n                allowedSourceLayers.has(sourceLayer)\n            );\n        })\n        .map((layer) => {\n            if (layer.type !== \"fill\" || layer[\"source-layer\"] !== \"water\") {\n                return layer;\n            }\n            return {\n                ...layer,\n                paint: {\n                    ...(layer.paint || {}),\n                    \"fill-opacity\": 0.8,\n                },\n            };\n        });\n\n    return {\n        ...styleJson,\n        layers: filteredLayers,\n        sprite: `https://protomaps.github.io/basemaps-assets/sprites/v4/${DEFAULT_FLAVOR}`,\n    };\n}\n\nfunction getGroupedManagedLayers(map) {\n    if (!map || !map.getStyle) {\n        return {};\n    }\n    const style = map.getStyle();\n    const groups = {};\n    const claimed = new Set();\n    MANAGED_OVERLAY_GROUPS.forEach((group) => {\n        groups[group.key] = [];\n        (style.layers || []).forEach((layer) => {\n            if (claimed.has(layer.id)) {\n                return;\n            }\n            if (\n                layer.type === group.type &&\n                layer[\"source-layer\"] === group.sourceLayer\n            ) {\n                groups[group.key].push(layer.id);\n                claimed.add(layer.id);\n            }\n        });\n    });\n    return groups;\n}\n\nfunction getManagedLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return MANAGED_OVERLAY_GROUPS.flatMap((group) => grouped[group.key] || []);\n}\n\nfunction getAdminBoundaryLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return grouped.adminLines || [];\n}\n\nfunction getBoundaryLabelLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return [...(grouped.adminBoundaryLabels || []), ...(grouped.adminAreaLabels || [])];\n}\n\nfunction applyBoundaryLineContrast(map, layerId) {\n    if (!map || !map.getLayer(layerId)) {\n        return;\n    }\n    const style = map.getStyle();\n    const layerDef = (style.layers || []).find((layer) => layer.id === layerId);\n    if (!layerDef) {\n        return;\n    }\n    const basePaint = layerDef.paint || {};\n    const baseWidth = basePaint[\"line-width\"] ?? 1;\n    const casingLayerId = `${layerId}__contrast_casing`;\n    if (map.getLayer(casingLayerId)) {\n        map.removeLayer(casingLayerId);\n    }\n\n    const casingPaint = {\n        ...basePaint,\n        \"line-color\": BOUNDARY_CONTRAST.lineCasingColor,\n        \"line-opacity\": BOUNDARY_CONTRAST.lineCasingOpacity,\n        \"line-width\": [\"+\", baseWidth, BOUNDARY_CONTRAST.lineCasingExtraWidth],\n    };\n\n    try {\n        map.addLayer(\n            {\n                ...layerDef,\n                id: casingLayerId,\n                paint: casingPaint,\n            },\n            layerId\n        );\n    } catch (error) {\n        console.warn(`Failed to add contrast casing for ${layerId}:`, error);\n    }\n\n    map.setPaintProperty(layerId, \"line-color\", BOUNDARY_CONTRAST.lineStrokeColor);\n    map.setPaintProperty(\n        layerId,\n        \"line-opacity\",\n        BOUNDARY_CONTRAST.lineStrokeOpacity\n    );\n}\n\nfunction applyBoundaryLabelContrast(map, layerId) {\n    if (!map || !map.getLayer(layerId)) {\n        return;\n    }\n    map.setPaintProperty(layerId, \"text-color\", BOUNDARY_CONTRAST.labelTextColor);\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-color\",\n        BOUNDARY_CONTRAST.labelHaloColor\n    );\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-width\",\n        BOUNDARY_CONTRAST.labelHaloWidth\n    );\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-blur\",\n        BOUNDARY_CONTRAST.labelHaloBlur\n    );\n}\n\nfunction applyBoundaryContrastOverrides(map) {\n    getAdminBoundaryLayerIds(map).forEach((layerId) => {\n        applyBoundaryLineContrast(map, layerId);\n    });\n    getBoundaryLabelLayerIds(map).forEach((layerId) => {\n        applyBoundaryLabelContrast(map, layerId);\n    });\n}\n\nfunction applyManagedOverlayLayerOrder(map) {\n    getManagedLayerIds(map).forEach((layerId) => {\n        if (!map.getLayer(layerId)) {\n            return;\n        }\n        try {\n            map.moveLayer(layerId);\n        } catch (error) {\n            console.warn(`Failed to move managed layer ${layerId}:`, error);\n        }\n    });\n}\n\nfunction getRasterInsertBeforeId(map) {\n    return getManagedLayerIds(map).find((layerId) => map.getLayer(layerId)) || null;\n}\n\nfunction getRasterSlotId(slot) {\n    return `${TERRACOTTA_LAYER_ID}-${slot}`;\n}\n\nfunction removeRasterSlot(map, slot) {\n    const slotId = getRasterSlotId(slot);\n    if (map.getLayer(slotId)) {\n        map.removeLayer(slotId);\n    }\n    if (map.getSource(slotId)) {\n        map.removeSource(slotId);\n    }\n}\n\nfunction setRasterLayer(map, tileUrl, slot = 0, opacity = TERRACOTTA_OPACITY) {\n    if (!map || !tileUrl) {\n        return;\n    }\n    const slotId = getRasterSlotId(slot);\n    removeRasterSlot(map, slot);\n\n    map.addSource(slotId, {\n        type: \"raster\",\n        tiles: [tileUrl],\n        tileSize: 256,\n    });\n\n    const layerDefinition = {\n        id: slotId,\n        type: \"raster\",\n        source: slotId,\n        paint: {\n            \"raster-opacity\": opacity,\n            \"raster-fade-duration\": 0,\n        },\n    };\n    const beforeLayerId = getRasterInsertBeforeId(map);\n    if (beforeLayerId) {\n        map.addLayer(layerDefinition, beforeLayerId);\n    } else {\n        map.addLayer(layerDefinition);\n    }\n    applyManagedOverlayLayerOrder(map);\n    return slotId;\n}\n\nfunction fadeRasterOpacity(map, layerId, fromOpacity, toOpacity, durationMs) {\n    if (!map.getLayer(layerId)) {\n        return Promise.resolve();\n    }\n    const clampOpacity = (value) => Math.max(0, Math.min(1, Number(value) || 0));\n    const safeFromOpacity = clampOpacity(fromOpacity);\n    const safeToOpacity = clampOpacity(toOpacity);\n    if (durationMs <= 0 || fromOpacity === toOpacity) {\n        map.setPaintProperty(layerId, \"raster-opacity\", safeToOpacity);\n        return Promise.resolve();\n    }\n    const start = performance.now();\n    return new Promise((resolve) => {\n        const step = (now) => {\n            if (!map.getLayer(layerId)) {\n                resolve();\n                return;\n            }\n            const t = Math.max(0, Math.min(1, (now - start) / durationMs));\n            const current = safeFromOpacity + (safeToOpacity - safeFromOpacity) * t;\n            map.setPaintProperty(layerId, \"raster-opacity\", clampOpacity(current));\n            if (t >= 1) {\n                resolve();\n                return;\n            }\n            requestAnimationFrame(step);\n        };\n        requestAnimationFrame(step);\n    });\n}\n\nasync function swapRasterLayer(runtime, tileUrl) {\n    const map = runtime?.map;\n    if (!map || !tileUrl) {\n        return;\n    }\n    const oldSlot = runtime.rasterSlot ?? 0;\n    const nextSlot = oldSlot === 0 ? 1 : 0;\n    const nextSlotId = setRasterLayer(map, tileUrl, nextSlot, 0);\n    const oldSlotId = getRasterSlotId(oldSlot);\n    const swapToken = (runtime.rasterSwapToken || 0) + 1;\n    runtime.rasterSwapToken = swapToken;\n\n    await new Promise((resolve) => {\n        let settled = false;\n        const finish = () => {\n            if (settled) {\n                return;\n            }\n            settled = true;\n            map.off(\"sourcedata\", onSourceData);\n            resolve();\n        };\n        const onSourceData = (event) => {\n            if (event.sourceId !== nextSlotId) {\n                return;\n            }\n            if (map.isSourceLoaded(nextSlotId)) {\n                finish();\n            }\n        };\n        map.on(\"sourcedata\", onSourceData);\n        window.setTimeout(finish, RASTER_LOAD_TIMEOUT_MS);\n    });\n\n    if (runtime.rasterSwapToken !== swapToken) {\n        return;\n    }\n\n    await Promise.all([\n        fadeRasterOpacity(\n            map,\n            nextSlotId,\n            0,\n            TERRACOTTA_OPACITY,\n            RASTER_CROSSFADE_MS\n        ),\n        fadeRasterOpacity(\n            map,\n            oldSlotId,\n            TERRACOTTA_OPACITY,\n            0,\n            RASTER_CROSSFADE_MS\n        ),\n    ]);\n\n    removeRasterSlot(map, oldSlot);\n    runtime.rasterSlot = nextSlot;\n}\n\nfunction getMaplibreGlobal() {\n    if (globalThis && globalThis.maplibregl) {\n        return globalThis.maplibregl;\n    }\n    if (window.maplibregl) {\n        return window.maplibregl;\n    }\n    if (window.parent && window.parent.maplibregl) {\n        return window.parent.maplibregl;\n    }\n    if (window.top && window.top.maplibregl) {\n        return window.top.maplibregl;\n    }\n    return null;\n}\n\nfunction waitForMaplibreGlobal(timeoutMs = 4000) {\n    return new Promise((resolve, reject) => {\n        if (getMaplibreGlobal()) {\n            resolve();\n            return;\n        }\n        const start = Date.now();\n        const tick = () => {\n            if (getMaplibreGlobal()) {\n                resolve();\n                return;\n            }\n            if (Date.now() - start > timeoutMs) {\n                reject(new Error(\"maplibregl global not available\"));\n                return;\n            }\n            window.setTimeout(tick, 50);\n        };\n        tick();\n    });\n}\n\nfunction loadMaplibre() {\n    if (getMaplibreGlobal()) {\n        return Promise.resolve();\n    }\n    if (maplibreReady) {\n        return maplibreReady;\n    }\n    maplibreReady = new Promise((resolve, reject) => {\n        const script = document.createElement(\"script\");\n        script.src = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js\";\n        script.crossOrigin = \"anonymous\";\n        script.onload = () => {\n            waitForMaplibreGlobal()\n                .then(() => {\n                    const global = getMaplibreGlobal();\n                    if (global && !window.maplibregl) {\n                        window.maplibregl = global;\n                    }\n                    resolve();\n                })\n                .catch(() => {\n                    import(\"https://esm.sh/maplibre-gl@3.6.2\")\n                        .then((module) => {\n                            window.maplibregl = module.default || module;\n                            return waitForMaplibreGlobal();\n                        })\n                        .then(resolve)\n                        .catch((error) => {\n                            reject(\n                                new Error(\n                                    `Failed to load maplibre-gl (global + esm). ${error}`\n                                )\n                            );\n                        });\n                });\n        };\n        script.onerror = () => {\n            import(\"https://esm.sh/maplibre-gl@3.6.2\")\n                .then((module) => {\n                    window.maplibregl = module.default || module;\n                    return waitForMaplibreGlobal();\n                })\n                .then(resolve)\n                .catch((error) => {\n                    reject(\n                        new Error(\n                            `Failed to load maplibre-gl.js and esm import. ${error}`\n                        )\n                    );\n                });\n        };\n        document.head.appendChild(script);\n    });\n    return maplibreReady;\n}\n\n// \u2500\u2500\u2500 \"No Data\" overlay helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfunction resolveNoDataOverlayHost(containerEl) {\n    if (!containerEl) {\n        return null;\n    }\n\n    if (typeof containerEl.closest === \"function\") {\n        const multimapFrame = containerEl.closest(\".bt-multimap-map\");\n        if (multimapFrame) {\n            return multimapFrame;\n        }\n\n        const mapShell = containerEl.closest(\".map-shell\");\n        if (mapShell) {\n            return mapShell;\n        }\n    }\n\n    return containerEl.parentElement || containerEl;\n}\n\nfunction createNoDataOverlayElement(extraClassName) {\n    const overlay = document.createElement(\"div\");\n    overlay.className = [\"no-data-overlay\", extraClassName]\n        .filter(Boolean)\n        .join(\" \");\n    overlay.innerHTML = `\n      <div style=\"display:flex;flex-direction:column;align-items:center;gap:6px;\">\n        <svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"rgba(255,255,255,0.7)\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\"/>\n          <line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"12\"/>\n          <line x1=\"12\" y1=\"16\" x2=\"12.01\" y2=\"16\"/>\n        </svg>\n        <span style=\"font-size:15px;font-weight:600;color:rgba(255,255,255,0.88);\">No data available</span>\n        <span style=\"font-size:12px;color:rgba(255,255,255,0.5);\">This forecast/metric combination has no results</span>\n      </div>\n    `;\n    return overlay;\n}\n\nfunction showNoDataOverlay(containerEl) {\n    const host = resolveNoDataOverlayHost(containerEl);\n    if (!host) return;\n\n    let overlay = host.querySelector(\".no-data-overlay\");\n    if (!overlay) {\n        overlay = createNoDataOverlayElement();\n        host.appendChild(overlay);\n    }\n    overlay.style.display = \"flex\";\n}\n\nfunction hideNoDataOverlay(containerEl) {\n    const host = resolveNoDataOverlayHost(containerEl);\n    if (!host) return;\n\n    const overlay = host.querySelector(\".no-data-overlay\");\n    if (overlay) overlay.style.display = \"none\";\n}\n\n// \u2500\u2500\u2500 Humanize lead labels (week1 \u2192 Week 1) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfunction humanizeLeadLabel(lead) {\n    const m = String(lead || \"\").match(/^week(\\d+)$/i);\n    if (m) return `Week ${m[1]}`;\n    return lead;\n}\n\nfunction injectContainerAndStyles() {\n    const mapMountId = `${MAP_CONTAINER_ID}__mount`;\n    const existing = getOrCreateHostContainer();\n    if (existing.querySelector(`#${mapMountId}`)) {\n        const existingMount = document.getElementById(mapMountId);\n        return existingMount;\n    }\n\n    const style = document.createElement(\"style\");\n    style.textContent = `\n    :root {\n      --ink:#0c1f2e;\n      --panel:#f5f3ef;\n    }\n    .map-shell {\n      position:relative;\n      width:100%;\n      height:70vh;\n      min-height:60vh;\n      font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n      border-radius:18px;\n      overflow:hidden;\n      box-shadow:0 16px 40px rgba(8, 16, 28, 0.25);\n      border:1px solid rgba(12, 31, 46, 0.2);\n      background:#0b1220;\n    }\n    .map-mount {\n      position:absolute;\n      inset:0;\n      width:100%;\n      height:100%;\n    }\n    .maplibregl-canvas {\n      width:100% !important;\n      height:100% !important;\n    }\n    /* \u2500\u2500 Enlarged color scale \u2500\u2500 */\n    #map-colorscale {\n      position:absolute;\n      left:14px;\n      bottom:14px;\n      z-index:4;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      pointer-events:none;\n      background:rgba(245, 243, 239, 0.96);\n      color:var(--ink);\n      padding:7px 14px;\n      border-radius:10px;\n      border:1px solid rgba(12, 31, 46, 0.18);\n      font-size:14px;\n      line-height:1.3;\n      min-height:30px;\n      white-space:nowrap;\n      box-shadow:0 12px 24px rgba(8, 16, 28, 0.15);\n    }\n    /* \u2500\u2500 No-data overlay \u2500\u2500 */\n    .no-data-overlay {\n      position:absolute;\n      inset:0;\n      z-index:5;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      background:rgba(11,18,32,0.82);\n      backdrop-filter:blur(2px);\n      pointer-events:none;\n      font-family:\"IBM Plex Sans\",\"Segoe UI\",sans-serif;\n    }\n    /* \u2500\u2500 Multimap: larger lead week labels \u2500\u2500 */\n    .bt-multimap-lead-label {\n      font-size:16px !important;\n      font-weight:600 !important;\n      letter-spacing:0.01em;\n    }\n    /* \u2500\u2500 Multimap: enlarged per-row color scales \u2500\u2500 */\n    .bt-multimap-row-scale,\n    .bt-multimap-map-scale {\n      font-size:14px !important;\n      padding:6px 12px !important;\n    }\n    /* \u2500\u2500 Metric description panel \u2500\u2500 */\n    #metric-description-panel {\n      margin-bottom:10px;\n    }\n`;\n    document.head.appendChild(style);\n\n    const hostContainer = getOrCreateHostContainer();\n\n    hostContainer.innerHTML = `\n      <div id=\"metric-description-panel\"></div>\n      <div class=\"map-shell\" id=\"map-shell-main\">\n        <div id=\"${mapMountId}\" class=\"map-mount\"></div>\n        <div id=\"map-colorscale\"></div>\n      </div>\n    `;\n\n    const cssHref = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css\";\n\n    // Preload CSS so the browser starts fetching immediately\n    if (!document.querySelector(`link[rel=\"preload\"][href=\"${cssHref}\"]`)) {\n        const preload = document.createElement(\"link\");\n        preload.rel = \"preload\";\n        preload.as = \"style\";\n        preload.href = cssHref;\n        document.head.appendChild(preload);\n    }\n\n    const css = document.createElement(\"link\");\n    css.rel = \"stylesheet\";\n    css.href = cssHref;\n    document.head.appendChild(css);\n\n    // Kick off MapLibre script load eagerly (non-blocking)\n    loadMaplibre();\n    return document.getElementById(mapMountId);\n}\n\nfunction createSingleMapInstance(container, baseStyle) {\n    const mapContainer =\n        container || document.getElementById(`${MAP_CONTAINER_ID}__mount`) || MAP_CONTAINER_ID;\n    const fullscreenContainer =\n        typeof mapContainer?.closest === \"function\"\n            ? mapContainer.closest(\".map-shell\")\n            : document.getElementById(\"map-shell-main\");\n    function forceCompactAttribution(mapInstance) {\n        if (!mapInstance || !mapInstance.getContainer) return;\n        const root = mapInstance.getContainer();\n        const attributions = root.querySelectorAll(\".maplibregl-ctrl-attrib\");\n        attributions.forEach((control) => {\n            control.classList.add(\"maplibregl-compact\");\n            control.classList.remove(\"maplibregl-compact-show\");\n        });\n    }\n    const map = new window.maplibregl.Map({\n        container: mapContainer,\n        style: baseStyle,\n        center: [0, 20],\n        zoom: 1.2,\n        attributionControl: false,\n        cooperativeGestures: false,\n    });\n\n    map.addControl(\n        new window.maplibregl.NavigationControl({ showCompass: false })\n    );\n    map.addControl(\n        new window.maplibregl.FullscreenControl(\n            fullscreenContainer ? { container: fullscreenContainer } : {}\n        ),\n        \"top-right\"\n    );\n    map.addControl(\n        new window.maplibregl.AttributionControl({ compact: true })\n    );\n    map.on(\"load\", () => forceCompactAttribution(map));\n    window.setTimeout(() => forceCompactAttribution(map), 0);\n\n    return map;\n}\n// EXTERNAL:time_grouping_utilities.js\n\nconst MONTH_NAMES = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n];\n\nconst MONTH_CODE_TO_NAME = MONTH_NAMES.reduce((acc, name, idx) => {\n    const monthNum = idx + 1;\n    acc[`M${String(monthNum).padStart(2, \"0\")}`] = name;\n    return acc;\n}, {});\n\nconst MONTH_NAME_TO_NUMBER = MONTH_NAMES.reduce((acc, name, idx) => {\n    acc[name.toLowerCase()] = idx + 1;\n    return acc;\n}, {});\n\nfunction parseMonthToken(rawValue) {\n    const value = String(rawValue || \"\").trim();\n    if (!value) {\n        return null;\n    }\n\n    const monthCodeMatch = value.match(/^M(0?[1-9]|1[0-2])$/i);\n    if (monthCodeMatch) {\n        return Number(monthCodeMatch[1]);\n    }\n\n    const monthNumberMatch = value.match(/^(0?[1-9]|1[0-2])$/);\n    if (monthNumberMatch) {\n        return Number(monthNumberMatch[1]);\n    }\n\n    return MONTH_NAME_TO_NUMBER[value.toLowerCase()] || null;\n}\n\nfunction formatMonthToken(monthNumber, outputMode = \"MXX\") {\n    if (!Number.isFinite(monthNumber) || monthNumber < 1 || monthNumber > 12) {\n        return \"\";\n    }\n    if (outputMode === \"NUMBER\") {\n        return String(monthNumber);\n    }\n    return `M${String(monthNumber).padStart(2, \"0\")}`;\n}\n\nfunction normalizeTimeFilter(raw, outputMode = \"MXX\") {\n    if (!raw || raw === \"None\") {\n        return raw;\n    }\n\n    return String(raw)\n        .split(\",\")\n        .map((part) => {\n            const trimmed = part.trim();\n            const monthNumber = parseMonthToken(trimmed);\n            if (!monthNumber) {\n                return trimmed;\n            }\n            return formatMonthToken(monthNumber, outputMode);\n        })\n        .join(\",\");\n}\n\nfunction humanizeTimeFilter(raw) {\n    if (!raw || raw === \"None\") return raw;\n\n    return String(raw)\n        .split(\",\")\n        .map((part) => {\n            const monthNumber = parseMonthToken(part);\n            if (!monthNumber) {\n                return String(part).trim();\n            }\n            return MONTH_NAMES[monthNumber - 1];\n        })\n        .join(\", \");\n}\n// EXTERNAL:metrics_utilities.js\n\n// \u2500\u2500\u2500 Units lookup \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// Some metrics are inherently unitless (correlations, skill scores, ratios).\n// Only error metrics that are in the same units as the variable get product units.\nconst UNITLESS_METRICS = new Set([\n    \"acc\", \"pearson\", \"smape\", \"seeps\",\n    \"bss\", \"spread_skill\",\n]);\nconst UNITLESS_METRIC_PREFIXES = [\n    \"heidke-\", \"pod-\", \"far-\", \"ets-\", \"csi-\",\n];\n\nfunction isUnitlessMetric(metric) {\n    const m = String(metric || \"\").toLowerCase();\n    if (UNITLESS_METRICS.has(m)) return true;\n    return UNITLESS_METRIC_PREFIXES.some((prefix) => m.startsWith(prefix));\n}\n\nfunction getUnitsForProduct(product) {\n    const p = String(product || \"\").toLowerCase();\n    if (p.includes(\"precip\") || p.includes(\"rain\") || p.includes(\"tp\")) {\n        return \"mm/day\";\n    }\n    if (\n        p.includes(\"tmp2m\") ||\n        p.includes(\"t2m\") ||\n        p.includes(\"temp\") ||\n        p.includes(\"sst\")\n    ) {\n        return \"\u00b0C\";\n    }\n    if (p.includes(\"wind\") || p.includes(\"u10\") || p.includes(\"v10\")) {\n        return \"m/s\";\n    }\n    if (p.includes(\"slp\") || p.includes(\"mslp\") || p.includes(\"pressure\")) {\n        return \"hPa\";\n    }\n    if (p.includes(\"z500\") || p.includes(\"geopotential\")) {\n        return \"m\u00b2/s\u00b2\";\n    }\n    return \"\";\n}\n\n/** Resolve display units given both the metric and the product.\n *  Unitless metrics (correlations, skill scores) return \"\". */\nfunction getUnits(metric, product) {\n    if (isUnitlessMetric(metric)) return \"\";\n    return getUnitsForProduct(product);\n}\n\n// \u2500\u2500\u2500 Metric descriptions \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// direction: \"lower\" (smaller is better), \"higher\" (larger is better), \"zero\" (ideal = 0)\nconst METRIC_DESCRIPTIONS = {\n    mae: {\n        name: \"Mean Absolute Error (MAE)\",\n        description:\n            \"Mean absolute error measures the average magnitude of the errors in a set of predictions, without considering their direction.\",\n        direction: \"lower\",\n    },\n    rmse: {\n        name: \"Root Mean Square Error (RMSE)\",\n        description:\n            \"Root mean squared error gives higher weight to large errors.\",\n        direction: \"lower\",\n    },\n    crps: {\n        name: \"Continuous Ranked Probability Score (CRPS)\",\n        description:\n            \"Continuous ranked probability score assesses probabilistic forecast accuracy.\",\n        direction: \"lower\",\n    },\n    bias: {\n        name: \"Bias\",\n        description:\n            \"Bias measures signed error magnitude.\",\n        direction: \"zero\",\n    },\n    smape: {\n        name: \"SMAPE\",\n        description:\n            \"SMAPE expresses error as a percent of total value (precip only). Range [0, 1].\",\n        direction: \"lower\",\n    },\n    seeps: {\n        name: \"Stable Equitable Error in Probability Space (SEEPS)\",\n        description:\n            \"SEEPS evaluates rainfall forecasts accounting for climatology.\",\n        direction: \"lower\",\n    },\n    acc: {\n        name: \"Anomaly Correlation Coefficient (ACC)\",\n        description:\n            \"Anomaly correlation coefficient compares forecast and observed anomalies relative to climatology. Range [\u22121, 1].\",\n        direction: \"higher\",\n    },\n    pearson: {\n        name: \"Pearson Correlation\",\n        description:\n            \"Pearson correlation measures linear association between predictions and observations. Range [\u22121, 1].\",\n        direction: \"higher\",\n    },\n    spread: {\n        name: \"Spread\",\n        description:\n            \"The ensemble spread (standard deviation) of forecasts. Useful for assessing whether forecast uncertainty is well calibrated.\",\n        direction: null,\n    },\n    bss: {\n        name: \"Brier Skill Score (BSS)\",\n        description:\n            \"Measures the improvement of a probabilistic forecast over a reference (climatology). Positive values indicate skill above the reference.\",\n        direction: \"higher\",\n    },\n};\n\n// Prefix-based metrics (heidke-*, pod-*, far-*, ets-*, csi-*)\nconst PREFIX_METRIC_DESCRIPTIONS = [\n    {\n        prefix: \"heidke-\",\n        name: \"Heidke Skill Score (HSS)\",\n        description:\n            \"Heidke skill score compares forecast accuracy against random chance for one or more event thresholds. Range [\u2212\u221e, 1].\",\n        direction: \"higher\",\n    },\n    {\n        prefix: \"pod-\",\n        name: \"Probability of Detection (POD)\",\n        description:\n            \"Probability of detection = fraction of observed events correctly forecast. Range [0, 1].\",\n        direction: \"higher\",\n    },\n    {\n        prefix: \"csi-\",\n        name: \"Critical Success Index (CSI)\",\n        description:\n            \"Critical success index measures the fraction of observed and/or forecast events that were correctly predicted (hits \u00f7 hits + misses + false alarms). Range [0, 1].\",\n        direction: \"higher\",\n    },\n    {\n        prefix: \"far-\",\n        name: \"False Alarm Rate (FAR)\",\n        description:\n            \"False alarm rate = fraction of predicted events not observed. Range [0, 1].\",\n        direction: \"lower\",\n    },\n    {\n        prefix: \"ets-\",\n        name: \"Equitable Threat Score (ETS)\",\n        description:\n            \"Equitable threat score measures threshold-event skill adjusted for chance. Range [\u2212\u2153, 1].\",\n        direction: \"higher\",\n    },\n];\n\nfunction lookupMetricInfo(metric) {\n    const m = String(metric || \"\").toLowerCase();\n    // Exact match first\n    if (METRIC_DESCRIPTIONS[m]) return METRIC_DESCRIPTIONS[m];\n    // Prefix match\n    for (const entry of PREFIX_METRIC_DESCRIPTIONS) {\n        if (m.startsWith(entry.prefix)) return entry;\n    }\n    return null;\n}\n\n/** Return the metric \"direction\" used by colormap logic. */\nfunction getMetricDirection(metric) {\n    const info = lookupMetricInfo(metric);\n    return info?.direction || null;\n}\n\nfunction renderMetricDescriptionHtml(metric) {\n    const info = lookupMetricInfo(metric);\n    if (!info) return \"\";\n\n    let directionHtml = \"\";\n    if (info.direction === \"lower\") {\n        directionHtml = `<span style=\"color:#d32f2f; font-weight:600;\">\ud83d\udd34 Smaller is better.</span>`;\n    } else if (info.direction === \"higher\") {\n        directionHtml = `<span style=\"color:#2e7d32; font-weight:600;\">\ud83d\udfe2 Larger is better.</span>`;\n    } else if (info.direction === \"zero\") {\n        directionHtml = `<span style=\"color:#757575; font-weight:600;\">\u26aa Ideal = 0.</span>`;\n    }\n\n    return `\n      <div style=\"\n        font-family:'IBM Plex Sans','Segoe UI',sans-serif;\n        background:transparent;\n        color:#0c1f2e;\n        border:1px solid rgba(12,31,46,0.18);\n        border-radius:10px;\n        padding:10px 16px;\n        margin-top:10px;\n        font-size:13px;\n        line-height:1.5;\n        box-shadow:0 4px 12px rgba(8,16,28,0.10);\n      \">\n        <strong style=\"font-size:14px;\">${info.name}</strong><br/>\n        <span style=\"opacity:0.82;\">${info.description}</span>\n        ${directionHtml ? `<br/>${directionHtml}` : \"\"}\n      </div>\n    `;\n}\n\n// \u2500\u2500\u2500 Refresh metric description panel \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfunction refreshMetricDescription(metric) {\n    const panel = document.getElementById(\"metric-description-panel\");\n    if (!panel) return;\n    panel.innerHTML = renderMetricDescriptionHtml(metric);\n}\n// EXTERNAL:color_utilities.js\nfunction getColorStops(colormap) {\n    const palette = colormap.endsWith(\"_r\") ? colormap.slice(0, -2) : colormap;\n    const paletteStops = {\n        brbg: [\n            \"#543005\",\n            \"#8c510a\",\n            \"#bf812d\",\n            \"#dfc27d\",\n            \"#f6e8c3\",\n            \"#f5f5f5\",\n            \"#c7eae5\",\n            \"#80cdc1\",\n            \"#35978f\",\n            \"#01665e\",\n            \"#003c30\",\n        ],\n        rdbu: [\n            \"#67001f\",\n            \"#b2182b\",\n            \"#d6604d\",\n            \"#f4a582\",\n            \"#fddbc7\",\n            \"#f7f7f7\",\n            \"#d1e5f0\",\n            \"#92c5de\",\n            \"#4393c3\",\n            \"#2166ac\",\n            \"#053061\",\n        ],\n        rdylgn: [\n            \"#a50026\",\n            \"#d73027\",\n            \"#f46d43\",\n            \"#fdae61\",\n            \"#fee08b\",\n            \"#ffffbf\",\n            \"#d9ef8b\",\n            \"#a6d96a\",\n            \"#66bd63\",\n            \"#1a9850\",\n            \"#006837\",\n        ],\n        blues: [\n            \"#f7fbff\",\n            \"#deebf7\",\n            \"#c6dbef\",\n            \"#9ecae1\",\n            \"#6baed6\",\n            \"#4292c6\",\n            \"#2171b5\",\n            \"#08519c\",\n            \"#08306b\",\n        ],\n        reds: [\n            \"#fff5f0\",\n            \"#fee0d2\",\n            \"#fcbba1\",\n            \"#fc9272\",\n            \"#fb6a4a\",\n            \"#ef3b2c\",\n            \"#cb181d\",\n            \"#a50f15\",\n            \"#67000d\",\n        ],\n    };\n    const stops = paletteStops[palette] || paletteStops.reds;\n    return colormap.endsWith(\"_r\") ? [...stops].reverse() : stops;\n}\n\nfunction renderColorScaleHtml(stretch, product, metric) {\n    if (!stretch) {\n        return \"<span style='font-size:14px;'>No stretch</span>\";\n    }\n    const decoded = decodeURIComponent(stretch);\n    const colormapMatch = decoded.match(/colormap=([^&]+)/);\n    const rangeMatch = decoded.match(/stretch_range=\\[([^\\]]+)\\]/);\n    const colormap = colormapMatch ? colormapMatch[1] : \"\";\n    const units = getUnits(metric, product);\n    const unitsSuffix = units ? ` ${units}` : \"\";\n    let min = \"min\";\n    let max = \"max\";\n    if (rangeMatch) {\n        const parts = rangeMatch[1].split(\",\").map((value) => Number(value.trim()));\n        if (parts.length >= 2) {\n            min = parts[0].toFixed(1);\n            max = parts[1].toFixed(1);\n        }\n    }\n    const stops = getColorStops(colormap);\n    const gradient = `linear-gradient(90deg, ${stops.join(\", \")})`;\n    return `\n      <div style=\"display:flex; align-items:center; height:100%; gap:8px; font-variant-numeric:tabular-nums; font-size:14px;\">\n        <span>${min}${unitsSuffix}</span>\n        <div style=\"width:120px; height:12px; border-radius:999px; background:${gradient};\"></div>\n        <span>${max}${unitsSuffix}</span>\n      </div>\n    `;\n}\n\nfunction refreshColorScale(stretch, product, metric) {\n    const scale = document.getElementById(\"map-colorscale\");\n    if (!scale) {\n        return;\n    }\n    scale.innerHTML = renderColorScaleHtml(stretch, product, metric);\n}\n// EXTERNAL:terracotta_dataset_utilities.js\nfunction buildDatasetId(params) {\n    const datasetFamily = params?.datasetFamily || \"grouped_metric\";\n    const { startDate, endDate } = resolveDatasetDates(datasetFamily);\n    const rawTimeFilter = params?.timeFilter;\n    const timeFilter =\n        typeof normalizeTimeFilter === \"function\"\n            ? normalizeTimeFilter(\n                rawTimeFilter,\n                params?.timeFilterOutputMode || \"MXX\"\n            )\n            : rawTimeFilter;\n    const timeSuffix =\n        timeFilter && timeFilter !== \"None\" ? `_${timeFilter}` : \"\";\n\n    if (datasetFamily === \"metric\") {\n        const aggDays = String(params?.aggDays || \"7\");\n        const { truth, category } = splitProduct(params?.product);\n        return (\n            [\n                \"metric\",\n                aggDays,\n                endDate,\n                params.forecast,\n                params.grid,\n                \"lsm\",\n                params.metric,\n                \"global\",\n                \"None\",\n                \"True\",\n                startDate,\n                params.timeGrouping,\n                truth,\n                category,\n            ].join(\"_\") + timeSuffix\n        );\n    }\n\n    return (\n        `grouped_metric_${endDate}_` +\n        `${params.forecast}_${params.grid}_${params.lead}_lsm_${params.metric}_` +\n        `${params.region}_True_${startDate}_${params.timeGrouping}_${params.product}` +\n        timeSuffix\n    );\n}\n\nfunction resolveDatasetDates(datasetFamily) {\n    if (datasetFamily === \"metric\") {\n        return { startDate: \"1998-01-01\", endDate: \"2024-12-31\" };\n    }\n    return { startDate: \"2016-01-01\", endDate: \"2022-12-31\" };\n}\n\nfunction splitProduct(product) {\n    const raw = String(product || \"\");\n    const firstUnderscore = raw.indexOf(\"_\");\n    if (firstUnderscore > 0 && firstUnderscore < raw.length - 1) {\n        return {\n            truth: raw.slice(0, firstUnderscore),\n            category: raw.slice(firstUnderscore + 1),\n        };\n    }\n    return { truth: \"era5\", category: raw || \"precip\" };\n}\n\nfunction extractPercentileBounds(metadata) {\n    const percentiles = metadata?.percentiles || [];\n    if (percentiles.length < 95) {\n        return null;\n    }\n    return [percentiles[4], percentiles[94]];\n}\n\nfunction buildStretchFromBounds(colorMin, colorMax, metric, product) {\n    const m = String(metric || \"\").toLowerCase();\n    let colormap = \"reds\";\n\n    // \u2500\u2500 Bias: diverging around 0 \u2500\u2500\n    if (m === \"bias\") {\n        // Symmetrise around zero\n        const absMax = Math.max(Math.abs(colorMin), Math.abs(colorMax));\n        colorMin = -absMax;\n        colorMax = absMax;\n        colormap = product === \"era5_tmp2m\" ? \"rdbu_r\" : \"brbg\";\n\n        // \u2500\u2500 ACC / Pearson: correlation [-1, 1], higher is better \u2500\u2500\n    } else if (m === \"acc\" || m === \"pearson\") {\n        colorMin = -1;\n        colorMax = 1;\n        colormap = \"rdylgn\";\n\n        // \u2500\u2500 SEEPS: fixed [0, 2], lower is better \u2500\u2500\n    } else if (m === \"seeps\") {\n        colorMin = 0;\n        colorMax = 2.0;\n        colormap = \"reds\";\n\n        // \u2500\u2500 SMAPE: fixed [0, 1], lower is better \u2500\u2500\n    } else if (m === \"smape\") {\n        colorMin = 0;\n        colorMax = 1;\n        colormap = \"reds\";\n\n        // \u2500\u2500 Heidke: higher is better, open lower bound up to 1 \u2500\u2500\n    } else if (m.startsWith(\"heidke-\")) {\n        // Keep data-driven min, cap max at 1\n        colorMax = 1;\n        colormap = \"rdylgn\";\n\n        // \u2500\u2500 POD: [0, 1], higher is better \u2500\u2500\n    } else if (m.startsWith(\"pod-\")) {\n        colorMin = 0;\n        colorMax = 1;\n        colormap = \"rdylgn\";\n\n        // \u2500\u2500 CSI: [0, 1], higher is better \u2500\u2500\n    } else if (m.startsWith(\"csi-\")) {\n        colorMin = 0;\n        colorMax = 1;\n        colormap = \"rdylgn\";\n\n        // \u2500\u2500 FAR: [0, 1], lower is better \u2500\u2500\n    } else if (m.startsWith(\"far-\")) {\n        colorMin = 0;\n        colorMax = 1;\n        colormap = \"reds\";\n\n        // \u2500\u2500 ETS: [-1/3, 1], higher is better \u2500\u2500\n    } else if (m.startsWith(\"ets-\")) {\n        colorMin = -1 / 3;\n        colorMax = 1;\n        colormap = \"rdylgn\";\n\n        // \u2500\u2500 MAE, RMSE, CRPS, and anything else: lower is better \u2500\u2500\n    } else {\n        // m === \"mae\" || m === \"rmse\" || m === \"crps\" || fallback\n        colormap = \"reds\";\n    }\n\n    return `colormap=${colormap}&stretch_range=[${colorMin},${colorMax}]`;\n}\n\nfunction computeStretch(metadata, metric, product) {\n    const bounds = extractPercentileBounds(metadata);\n    if (!bounds) {\n        return \"\";\n    }\n    return buildStretchFromBounds(bounds[0], bounds[1], metric, product);\n}\n\nfunction computeSharedStretchFromMetadata(metadataList, metric, product) {\n    const bounds = (metadataList || [])\n        .map((metadata) => extractPercentileBounds(metadata))\n        .filter((item) => Array.isArray(item));\n    if (!bounds.length) {\n        return \"\";\n    }\n    const colorMin = Math.min(...bounds.map((item) => item[0]));\n    const colorMax = Math.max(...bounds.map((item) => item[1]));\n    return buildStretchFromBounds(colorMin, colorMax, metric, product);\n}\n\nasync function fetchMetadata(params, signal) {\n    const datasetId = buildDatasetId(params);\n    const url = `${TERRACOTTA_BASE_URL}/metadata/${encodeURIComponent(datasetId)}`;\n    const response = await fetch(url, signal ? { signal } : undefined);\n    if (!response.ok) {\n        const error = new Error(`Metadata request failed (${response.status})`);\n        error.status = response.status;\n        throw error;\n    }\n    return response.json();\n}\n\nasync function fetchStretch(params, signal) {\n    const metadata = await fetchMetadata(params, signal);\n    return computeStretch(metadata, params.metric, params.product);\n}\n\nfunction buildTileUrl(params, stretch) {\n    const datasetId = buildDatasetId(params);\n    const base = `${TERRACOTTA_BASE_URL}/singleband/${encodeURIComponent(datasetId)}/{z}/{x}/{y}.png`;\n    if (!stretch) {\n        return { datasetId, tileUrl: base };\n    }\n    const query = encodeURIComponent(stretch)\n        .replace(/%26/g, \"&\")\n        .replace(/%3D/g, \"=\");\n    return { datasetId, tileUrl: `${base}?${query}` };\n}\n// EXTERNAL:maplibre-singlemap-orchestration.js\n\nfunction getPanelRoot() {\n    return (\n        document.querySelector(\"#panel-content\") ||\n        document.querySelector(\".panel-content\") ||\n        document.querySelector(\".panel-content--no-padding\") ||\n        document.querySelector(\".panel-container\") ||\n        document.body\n    );\n}\n\nfunction getOrCreateHostContainer() {\n    const existing = document.getElementById(MAP_CONTAINER_ID);\n    if (existing) {\n        return existing;\n    }\n    const host = document.createElement(\"div\");\n    host.id = MAP_CONTAINER_ID;\n    host.className = MAP_CONTAINER_ITEM_CLASS;\n    getPanelRoot().appendChild(host);\n    return host;\n}\n\nasync function initCurrentMapPage() {\n    const container = injectContainerAndStyles();\n\n    const params = {\n        ...VARS,\n        region: resolveRegion(VARS.forecast),\n    };\n\n    // Kick off all three network requests in parallel\n    const [maplibreResult, stretchResult, styleResult] = await Promise.allSettled([\n        loadMaplibre(),\n        fetchStretch(params),\n        fetchPreparedStyle(DEFAULT_FLAVOR),\n    ]);\n\n    // \u2500\u2500 Validate MapLibre loaded \u2500\u2500\n    if (maplibreResult.status === \"rejected\") {\n        console.error(\"MapLibre failed to load.\", maplibreResult.reason);\n        return;\n    }\n    if (!getMaplibreGlobal()) {\n        console.error(\"MapLibre is unavailable after load.\");\n        return;\n    }\n    if (!window.maplibregl && getMaplibreGlobal()) {\n        window.maplibregl = getMaplibreGlobal();\n    }\n\n    // \u2500\u2500 Resolve stretch (may have failed \u2192 no-data) \u2500\u2500\n    let stretch = \"\";\n    let fetchFailed = false;\n    if (stretchResult.status === \"fulfilled\") {\n        stretch = stretchResult.value;\n    } else {\n        console.error(\"Failed to fetch stretch\", stretchResult.reason);\n        fetchFailed = true;\n    }\n    refreshColorScale(stretch, params.product, params.metric);\n    refreshMetricDescription(params.metric);\n\n    // \u2500\u2500 Resolve base style \u2500\u2500\n    if (styleResult.status === \"rejected\") {\n        console.error(\"Failed to fetch prepared style\", styleResult.reason);\n        return;\n    }\n    const baseStyle = styleResult.value;\n\n    const { datasetId, tileUrl } = buildTileUrl(params, stretch);\n\n    const existingRuntime = window.__grafanaMaplibre;\n    if (existingRuntime?.pollHandle) {\n        window.clearInterval(existingRuntime.pollHandle);\n    }\n    if (existingRuntime && existingRuntime.map) {\n        try {\n            existingRuntime.map.remove();\n        } catch (error) {\n            console.warn(\"Failed to remove existing map\", error);\n        }\n    }\n\n    const map = createSingleMapInstance(container, baseStyle);\n\n    window.__grafanaMaplibre = {\n        map,\n        datasetId,\n        tileUrl,\n        stretch,\n        params,\n        rasterSlot: 0,\n        rasterSwapToken: 0,\n        ready: false,\n    };\n\n    map.on(\"load\", () => {\n        window.__grafanaMaplibre.ready = true;\n        applyBoundaryContrastOverrides(map);\n        if (fetchFailed || !stretch) {\n            showNoDataOverlay(container);\n        } else {\n            hideNoDataOverlay(container);\n            setRasterLayer(map, tileUrl, 0, TERRACOTTA_OPACITY);\n        }\n        removeRasterSlot(map, 1);\n    });\n\n    let pendingVars = null;\n    let pendingSince = 0;\n    let refreshToken = 0;\n\n    window.__grafanaMaplibre.pollHandle = window.setInterval(async () => {\n        if (!window.__grafanaMaplibre?.ready) {\n            return;\n        }\n\n        const observedVars = readVars();\n        const observedSig = JSON.stringify(observedVars);\n        const currentSig = JSON.stringify(VARS);\n        if (observedSig === currentSig) {\n            pendingVars = null;\n            pendingSince = 0;\n            return;\n        }\n\n        if (!pendingVars || JSON.stringify(pendingVars) !== observedSig) {\n            pendingVars = observedVars;\n            pendingSince = Date.now();\n            return;\n        }\n\n        if (Date.now() - pendingSince < VAR_STABILIZE_MS) {\n            return;\n        }\n\n        VARS = pendingVars;\n        pendingVars = null;\n        pendingSince = 0;\n        const nextParams = {\n            ...VARS,\n            region: resolveRegion(VARS.forecast),\n        };\n\n        if (stretchRequestController) {\n            stretchRequestController.abort();\n        }\n        stretchRequestController = new AbortController();\n        const token = ++refreshToken;\n\n        let nextStretch = \"\";\n        let nextFetchFailed = false;\n        try {\n            nextStretch = await fetchStretch(\n                nextParams,\n                stretchRequestController.signal\n            );\n        } catch (error) {\n            if (error?.name === \"AbortError\") {\n                return;\n            }\n            console.error(\"Failed to fetch stretch\", error);\n            nextFetchFailed = true;\n        }\n        if (token !== refreshToken) {\n            return;\n        }\n\n        // Handle no-data state\n        if (nextFetchFailed || !nextStretch) {\n            showNoDataOverlay(container);\n            removeRasterSlot(map, 0);\n            removeRasterSlot(map, 1);\n            refreshColorScale(\"\", nextParams.product, nextParams.metric);\n        } else {\n            hideNoDataOverlay(container);\n\n            const next = buildTileUrl(nextParams, nextStretch);\n            if (nextStretch !== window.__grafanaMaplibre.stretch) {\n                refreshColorScale(nextStretch, nextParams.product, nextParams.metric);\n            }\n\n            if (next.tileUrl !== window.__grafanaMaplibre.tileUrl) {\n                await swapRasterLayer(window.__grafanaMaplibre, next.tileUrl);\n            }\n\n            window.__grafanaMaplibre.datasetId = next.datasetId;\n            window.__grafanaMaplibre.tileUrl = next.tileUrl;\n            window.__grafanaMaplibre.stretch = nextStretch;\n        }\n\n        // Always refresh metric description on variable change\n        refreshMetricDescription(nextParams.metric);\n        window.__grafanaMaplibre.params = nextParams;\n    }, POLL_INTERVAL_MS);\n}\n// EXTERNAL:maplibre-multimap-orchestration.js\n\nfunction ensureRuntimeContainer() {\n    const existingRuntime = window.__grafanaMaplibreMultimap;\n    if (existingRuntime?.pollHandle) {\n        window.clearInterval(existingRuntime.pollHandle);\n    }\n    if (existingRuntime?.cells) {\n        existingRuntime.cells.forEach((cellRuntime) => {\n            if (cellRuntime?.map) {\n                try {\n                    cellRuntime.map.remove();\n                } catch (error) {\n                    console.warn(\"Failed to remove existing multimap map\", error);\n                }\n            }\n        });\n    }\n}\n\nfunction applyManualSync(maps) {\n    let syncing = false;\n    const syncFrom = (sourceMap) => {\n        if (syncing) {\n            return;\n        }\n        syncing = true;\n        const center = sourceMap.getCenter();\n        const zoom = sourceMap.getZoom();\n        const bearing = sourceMap.getBearing();\n        const pitch = sourceMap.getPitch();\n\n        maps.forEach((map) => {\n            if (map === sourceMap) {\n                return;\n            }\n            map.jumpTo({ center, zoom, bearing, pitch });\n        });\n        syncing = false;\n    };\n\n    maps.forEach((map) => {\n        map.on(\"moveend\", () => syncFrom(map));\n        map.on(\"zoomend\", () => syncFrom(map));\n        map.on(\"dragend\", () => syncFrom(map));\n    });\n}\n\nfunction loadSyncMovePlugin() {\n    if (window.syncMaps && typeof window.syncMaps === \"function\") {\n        return Promise.resolve();\n    }\n    if (syncMoveReady) {\n        return syncMoveReady;\n    }\n\n    syncMoveReady = new Promise((resolve) => {\n        const script = document.createElement(\"script\");\n        script.src = \"https://unpkg.com/mapbox-gl-sync-move@0.3.1/index.js\";\n        script.onload = () => resolve();\n        script.onerror = () => resolve();\n        document.head.appendChild(script);\n    });\n\n    return syncMoveReady;\n}\n\nasync function synchronizeMaps(cellRuntimes) {\n    const maps = cellRuntimes.map((runtime) => runtime.map).filter(Boolean);\n    if (maps.length < 2) {\n        return;\n    }\n\n    await loadSyncMovePlugin();\n    if (window.syncMaps && typeof window.syncMaps === \"function\") {\n        try {\n            window.syncMaps(...maps);\n            return;\n        } catch (error) {\n            console.warn(\"syncMaps plugin failed, using fallback sync\", error);\n        }\n    }\n    applyManualSync(maps);\n}\n\nfunction buildCellParams(vars, cellDef) {\n    return {\n        forecast: vars.forecast,\n        grid: vars.grid,\n        metric: vars.metric,\n        product: cellDef.productValue,\n        lead: `week${cellDef.week}`,\n        timeGrouping: vars.timeGrouping,\n        timeFilter: vars.timeFilter,\n        timeFilterOutputMode: vars.timeFilterOutputMode,\n        region: resolveRegion(vars.forecast),\n    };\n}\n\nfunction setProductRowVisibility(productKey, visible) {\n    const row = document.getElementById(`bt-multimap-row-${productKey}`);\n    if (!row) {\n        return;\n    }\n    row.style.display = visible ? \"\" : \"none\";\n}\n\nfunction getOrCreateProductNoDataBanner(rowEl, productKey) {\n    if (!rowEl) {\n        return null;\n    }\n\n    let banner = rowEl.querySelector(\".bt-multimap-row-no-data\");\n    if (!banner) {\n        banner = createNoDataOverlayElement(\"bt-multimap-row-no-data\");\n        banner.dataset.productKey = productKey;\n        rowEl.appendChild(banner);\n    }\n    return banner;\n}\n\nfunction setProductRowNoDataState(productKey, hasData) {\n    const row = document.getElementById(`bt-multimap-row-${productKey}`);\n    if (!row) {\n        return;\n    }\n\n    const grid = row.querySelector(\".bt-multimap-grid\");\n    const banner = getOrCreateProductNoDataBanner(row, productKey);\n\n    if (grid) {\n        grid.style.display = hasData ? \"\" : \"none\";\n    }\n    if (banner) {\n        banner.style.display = hasData ? \"none\" : \"flex\";\n    }\n}\n\nfunction getCellOverlayContainer(cellRuntime) {\n    // Use canvas container so the shared helper appends overlay into the\n    // visible map frame (.bt-multimap-map), not the outer cell wrapper.\n    if (cellRuntime?.map?.getCanvasContainer) {\n        const canvasContainer = cellRuntime.map.getCanvasContainer();\n        if (canvasContainer) {\n            return canvasContainer;\n        }\n    }\n\n    if (cellRuntime?.map?.getContainer) {\n        const mapRoot = cellRuntime.map.getContainer();\n        if (mapRoot) {\n            return mapRoot;\n        }\n    }\n\n    if (cellRuntime?.def?.containerId) {\n        return document.getElementById(cellRuntime.def.containerId);\n    }\n\n    return null;\n}\n\nasync function refreshAllCells(runtime, vars) {\n    if (stretchRequestController) {\n        stretchRequestController.abort();\n    }\n    stretchRequestController = new AbortController();\n    const signal = stretchRequestController.signal;\n    const token = (runtime.refreshToken || 0) + 1;\n    runtime.refreshToken = token;\n\n    const metadataResults = await Promise.all(\n        runtime.cells.map(async (cellRuntime) => {\n            const nextParams = buildCellParams(vars, cellRuntime.def);\n            let metadata = null;\n            try {\n                metadata = await fetchMetadata(nextParams, signal);\n            } catch (error) {\n                if (error?.name !== \"AbortError\" && error?.status !== 404) {\n                    console.error(\"Failed to fetch metadata\", error);\n                }\n            }\n            return {\n                key: cellRuntime.def.key,\n                productKey: cellRuntime.def.productKey,\n                params: nextParams,\n                metadata,\n            };\n        })\n    );\n\n    if (runtime.refreshToken !== token) {\n        return;\n    }\n\n    const scaleByProduct = {};\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const leadMetadata = metadataResults\n            .filter(\n                (result) =>\n                    result.productKey === product.key && result.metadata !== null\n            )\n            .map((result) => result.metadata);\n        scaleByProduct[product.key] = computeSharedStretchFromMetadata(\n            leadMetadata,\n            vars.metric,\n            product.product\n        );\n    });\n\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const hasStretch = Boolean(scaleByProduct[product.key]);\n        setProductRowVisibility(product.key, true);\n        setProductRowNoDataState(product.key, hasStretch);\n        // Pass product and metric so units can be resolved correctly\n        const scaleMarkup = renderColorScaleHtml(scaleByProduct[product.key] || \"\", product.product, vars.metric);\n        const rowScaleEl = document.getElementById(\n            `bt-multimap-row-scale-${product.key}`\n        );\n        if (rowScaleEl) {\n            rowScaleEl.innerHTML = scaleMarkup;\n        }\n        const scaleEls = document.querySelectorAll(\n            `.bt-multimap-map-scale[data-product-key=\"${product.key}\"]`\n        );\n        scaleEls.forEach((scaleEl) => {\n            scaleEl.innerHTML = scaleMarkup;\n        });\n    });\n\n    const results = metadataResults.map((result) => {\n        const sharedStretch = scaleByProduct[result.productKey] || \"\";\n        if (!sharedStretch) {\n            return {\n                ...result,\n                stretch: \"\",\n                datasetId: buildDatasetId(result.params),\n                tileUrl: \"\",\n            };\n        }\n        if (result.metadata === null) {\n            return {\n                ...result,\n                stretch: sharedStretch,\n                datasetId: buildDatasetId(result.params),\n                tileUrl: \"\",\n            };\n        }\n        const next = buildTileUrl(result.params, sharedStretch);\n        return {\n            ...result,\n            stretch: sharedStretch,\n            datasetId: next.datasetId,\n            tileUrl: next.tileUrl,\n        };\n    });\n\n    // Refresh metric description for multimap too\n    refreshMetricDescription(vars.metric);\n\n    for (const result of results) {\n        const cellRuntime = runtime.cellsByKey.get(result.key);\n        if (!cellRuntime) {\n            continue;\n        }\n\n        const previousTileUrl = cellRuntime.tileUrl;\n        cellRuntime.params = result.params;\n        cellRuntime.stretch = result.stretch;\n        cellRuntime.datasetId = result.datasetId;\n        cellRuntime.tileUrl = result.tileUrl;\n\n        const overlayContainer = getCellOverlayContainer(cellRuntime);\n\n        if (!cellRuntime.ready) {\n            continue;\n        }\n\n        if (!result.tileUrl) {\n            removeRasterSlot(cellRuntime.map, 0);\n            removeRasterSlot(cellRuntime.map, 1);\n            showNoDataOverlay(overlayContainer);\n            continue;\n        }\n\n        hideNoDataOverlay(overlayContainer);\n\n        if (!previousTileUrl) {\n            setRasterLayer(cellRuntime.map, result.tileUrl, 0, TERRACOTTA_OPACITY);\n            removeRasterSlot(cellRuntime.map, 1);\n            continue;\n        }\n\n        if (previousTileUrl !== result.tileUrl) {\n            await swapRasterLayer(cellRuntime, result.tileUrl);\n        }\n    }\n}\n\nasync function initCurrentMultimapPage() {\n    const leadWeeks = getLeadWeeks(VARS.maxLead);\n    buildMultimapLayout(leadWeeks);\n\n    // Post-process: rename lead labels and month codes in the DOM\n    document.querySelectorAll(\".bt-multimap-lead-label\").forEach((el) => {\n        const raw = el.textContent.trim();\n        el.textContent = humanizeLeadLabel(raw);\n    });\n    // Rename any M01-style text in the layout\n    document.querySelectorAll(\"[data-time-filter]\").forEach((el) => {\n        const raw = el.getAttribute(\"data-time-filter\");\n        if (raw) el.textContent = humanizeTimeFilter(raw);\n    });\n\n    // Kick off MapLibre load and style fetch in parallel\n    const [maplibreResult, styleResult] = await Promise.allSettled([\n        loadMaplibre(),\n        fetchPreparedStyle(DEFAULT_FLAVOR),\n    ]);\n\n    // \u2500\u2500 Validate MapLibre loaded \u2500\u2500\n    if (maplibreResult.status === \"rejected\") {\n        console.error(\"MapLibre failed to load.\", maplibreResult.reason);\n        return;\n    }\n    if (!getMaplibreGlobal()) {\n        console.error(\"MapLibre is unavailable after load.\");\n        return;\n    }\n    if (!window.maplibregl && getMaplibreGlobal()) {\n        window.maplibregl = getMaplibreGlobal();\n    }\n\n    // \u2500\u2500 Resolve base style \u2500\u2500\n    if (styleResult.status === \"rejected\") {\n        console.error(\"Failed to fetch prepared style\", styleResult.reason);\n        return;\n    }\n    const baseStyle = styleResult.value;\n\n    ensureRuntimeContainer();\n\n    const defs = getCellDefinitions(leadWeeks);\n    const cells = defs\n        .map((def) => {\n            const container = document.getElementById(def.containerId);\n            if (!container) {\n                return null;\n            }\n            const map = createSingleMapInstance(container, baseStyle);\n            const cellRuntime = {\n                def,\n                map,\n                ready: false,\n                datasetId: \"\",\n                tileUrl: \"\",\n                stretch: \"\",\n                params: null,\n                rasterSlot: 0,\n                rasterSwapToken: 0,\n            };\n            map.on(\"load\", () => {\n                cellRuntime.ready = true;\n                applyBoundaryContrastOverrides(map);\n                const overlayContainer = getCellOverlayContainer(cellRuntime);\n                if (cellRuntime.tileUrl) {\n                    hideNoDataOverlay(overlayContainer);\n                    setRasterLayer(map, cellRuntime.tileUrl, 0, TERRACOTTA_OPACITY);\n                    removeRasterSlot(map, 1);\n                } else {\n                    showNoDataOverlay(overlayContainer);\n                }\n            });\n            return cellRuntime;\n        })\n        .filter(Boolean);\n\n    const cellsByKey = new Map(cells.map((cell) => [cell.def.key, cell]));\n\n    window.__grafanaMaplibreMultimap = {\n        cells,\n        cellsByKey,\n        refreshToken: 0,\n        pollHandle: null,\n    };\n\n    synchronizeMaps(cells);\n    await refreshAllCells(window.__grafanaMaplibreMultimap, VARS);\n\n    let pendingVars = null;\n    let pendingSince = 0;\n\n    window.__grafanaMaplibreMultimap.pollHandle = window.setInterval(async () => {\n        const observedVars = readVars();\n        const observedSig = JSON.stringify(observedVars);\n        const currentSig = JSON.stringify(VARS);\n        if (observedSig === currentSig) {\n            pendingVars = null;\n            pendingSince = 0;\n            return;\n        }\n\n        if (!pendingVars || JSON.stringify(pendingVars) !== observedSig) {\n            pendingVars = observedVars;\n            pendingSince = Date.now();\n            return;\n        }\n\n        if (Date.now() - pendingSince < VAR_STABILIZE_MS) {\n            return;\n        }\n\n        VARS = pendingVars;\n        pendingVars = null;\n        pendingSince = 0;\n\n        await refreshAllCells(window.__grafanaMaplibreMultimap, VARS);\n    }, POLL_INTERVAL_MS);\n}\n// EXTERNAL:maplibre-multimap-layout.js\nfunction ensureMultimapStyles() {\n    if (document.getElementById(\"bt-multimap-styles\")) {\n        return;\n    }\n    const style = document.createElement(\"style\");\n    style.id = \"bt-multimap-styles\";\n    style.textContent = `\n      .bt-multimap-root {\n        display:grid;\n        gap:18px;\n        width:100%;\n        font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n      }\n      #metric-description-panel {\n        margin-bottom:10px;\n      }\n      .bt-multimap-row {\n        display:grid;\n        gap:10px;\n      }\n      .bt-multimap-row-header {\n        display:flex;\n        align-items:center;\n        justify-content:space-between;\n        gap:12px;\n      }\n      .bt-multimap-row-title {\n        color:#0c1f2e;\n        font-size:16px;\n        font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n        font-weight:400;\n        line-height:1.2;\n      }\n      .bt-multimap-row-scale {\n        background:rgba(245, 243, 239, 0.75);\n        color:#0c1f2e;\n        padding:4px 8px;\n        border-radius:999px;\n        border:1px solid rgba(12, 31, 46, 0.18);\n        font-size:11px;\n        line-height:1;\n        min-height:24px;\n        display:flex;\n        align-items:center;\n        justify-content:center;\n        white-space:nowrap;\n      }\n      .bt-multimap-map-scale {\n        position:absolute;\n        left:10px;\n        bottom:10px;\n        z-index:4;\n        display:none;\n        pointer-events:none;\n        background:rgba(245, 243, 239, 0.96);\n        color:#0c1f2e;\n        padding:4px 8px;\n        border-radius:10px;\n        border:1px solid rgba(12, 31, 46, 0.18);\n        font-size:11px;\n        line-height:1.2;\n        min-height:22px;\n        align-items:center;\n        justify-content:center;\n        white-space:nowrap;\n      }\n      .bt-multimap-map:fullscreen .bt-multimap-map-scale,\n      .bt-multimap-map:-webkit-full-screen .bt-multimap-map-scale {\n        display:flex;\n      }\n      @media (max-width: 720px) {\n        .bt-multimap-row-header {\n          flex-wrap:wrap;\n          row-gap:8px;\n        }\n      }\n      .bt-multimap-grid {\n        display:grid;\n        gap:12px;\n        grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));\n      }\n      .bt-multimap-cell {\n        display:grid;\n        gap:6px;\n      }\n      .bt-multimap-cell-title {\n        font-size:12px;\n        color:#0c1f2e;\n        font-weight:600;\n      }\n      .bt-multimap-map {\n        position:relative;\n        width:100%;\n        height:280px;\n        border-radius:12px;\n        overflow:hidden;\n        box-shadow:0 10px 28px rgba(8, 16, 28, 0.2);\n        border:1px solid rgba(12, 31, 46, 0.2);\n        background:#0b1220;\n      }\n      .no-data-overlay {\n        position:absolute;\n        inset:0;\n        z-index:5;\n        display:flex;\n        align-items:center;\n        justify-content:center;\n        background:rgba(11, 18, 32, 0.82);\n        backdrop-filter:blur(2px);\n        pointer-events:none;\n        font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n      }\n      .bt-multimap-row-no-data {\n        position:relative;\n        inset:auto;\n        min-height:180px;\n        border-radius:12px;\n        border:1px solid rgba(12, 31, 46, 0.2);\n      }\n      .maplibregl-canvas {\n        width:100% !important;\n        height:100% !important;\n      }\n      @media (max-width: 900px) {\n        .bt-multimap-map {\n          height:240px;\n        }\n      }\n    `;\n    document.head.appendChild(style);\n\n    const css = document.createElement(\"link\");\n    css.rel = \"stylesheet\";\n    css.href = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css\";\n    document.head.appendChild(css);\n}\n\nfunction buildMultimapLayout(leadWeeks) {\n    ensureMultimapStyles();\n    const host = getOrCreateHostContainer();\n    let metricPanel = document.getElementById(\"metric-description-panel\");\n    if (!metricPanel) {\n        metricPanel = document.createElement(\"div\");\n        metricPanel.id = \"metric-description-panel\";\n        host.appendChild(metricPanel);\n    }\n\n    const rootId = \"bt-multimap-root\";\n    const existing = document.getElementById(rootId);\n    if (existing) {\n        if (metricPanel.nextElementSibling !== existing) {\n            host.insertBefore(metricPanel, existing);\n        }\n        return existing;\n    }\n\n    const root = document.createElement(\"div\");\n    root.id = rootId;\n    root.className = \"bt-multimap-root\";\n\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const row = document.createElement(\"div\");\n        row.className = \"bt-multimap-row\";\n        row.id = `bt-multimap-row-${product.key}`;\n\n        const header = document.createElement(\"div\");\n        header.className = \"bt-multimap-row-header\";\n\n        const rowTitle = document.createElement(\"div\");\n        rowTitle.className = \"bt-multimap-row-title\";\n        rowTitle.textContent = product.label;\n        header.appendChild(rowTitle);\n\n        const rowScale = document.createElement(\"div\");\n        rowScale.className = \"bt-multimap-row-scale\";\n        rowScale.id = `bt-multimap-row-scale-${product.key}`;\n        rowScale.innerHTML = \"Loading...\";\n        header.appendChild(rowScale);\n\n        row.appendChild(header);\n\n        const grid = document.createElement(\"div\");\n        grid.className = \"bt-multimap-grid\";\n\n        leadWeeks.forEach((week) => {\n            const cell = document.createElement(\"div\");\n            cell.className = \"bt-multimap-cell\";\n\n            const title = document.createElement(\"div\");\n            title.className = \"bt-multimap-cell-title\";\n            title.textContent = `Week ${week}`;\n            cell.appendChild(title);\n\n            const mapContainer = document.createElement(\"div\");\n            mapContainer.className = \"bt-multimap-map\";\n            mapContainer.id = `bt-multimap-${product.key}-week${week}`;\n\n            const scale = document.createElement(\"div\");\n            scale.className = \"bt-multimap-map-scale\";\n            scale.id = `bt-multimap-scale-${product.key}-week${week}`;\n            scale.dataset.productKey = product.key;\n            scale.innerHTML = \"Loading...\";\n            mapContainer.appendChild(scale);\n\n            cell.appendChild(mapContainer);\n\n            grid.appendChild(cell);\n        });\n\n        row.appendChild(grid);\n        root.appendChild(row);\n    });\n\n    host.appendChild(root);\n    if (metricPanel.nextElementSibling !== root) {\n        host.insertBefore(metricPanel, root);\n    }\n    return root;\n}\n\nfunction getCellDefinitions(leadWeeks) {\n    const cells = [];\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        leadWeeks.forEach((week) => {\n            cells.push({\n                key: `${product.key}-week${week}`,\n                productKey: product.key,\n                productValue: product.product,\n                week,\n                containerId: `bt-multimap-${product.key}-week${week}`,\n            });\n        });\n    });\n    return cells;\n}\n// EXTERNAL({\"panel_id\":\"multimap-forecast-evaluation\",\"key\":\"call-function\"}):bfd145p7u3jlse-multimap-forecast-evaluation-call-function.js\n(() => {\n    function runCurrentMultimapPanel() {\n        return initCurrentMultimapPage();\n    }\n\n    runCurrentMultimapPanel();\n})();\n",
        "content": "<div id=\"map-container\" style=\"height:900px\" />",
        "contentPartials": [],
        "defaultContent": "",
        "editor": {
          "format": "auto",
          "language": "html"
        },
        "editors": [
          "afterRender"
        ],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "data",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "6.2.0",
      "targets": [
        {
          "datasource": {
            "type": "datasource",
            "uid": "grafana"
          },
          "path": "img",
          "queryType": "list",
          "refId": "A"
        }
      ],
      "title": "",
      "transparent": true,
      "type": "marcusolsson-dynamictext-panel"
    }
  ],
  "preload": false,
  "refresh": "",
  "schemaVersion": 40,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "text": [
            "SOM",
            "KEN"
          ],
          "value": [
            "SOM",
            "KEN"
          ]
        },
        "hide": 2,
        "includeAll": false,
        "label": "Countries",
        "multi": true,
        "name": "countries",
        "options": [
          {
            "selected": false,
            "text": "Algeria",
            "value": "DZA"
          },
          {
            "selected": false,
            "text": "Angola",
            "value": "AGO"
          },
          {
            "selected": false,
            "text": "Benin",
            "value": "BEN"
          },
          {
            "selected": false,
            "text": "Botswana",
            "value": "BWA"
          },
          {
            "selected": false,
            "text": "Burkina Faso",
            "value": "BFA"
          },
          {
            "selected": false,
            "text": "Burundi",
            "value": "BDI"
          },
          {
            "selected": false,
            "text": "Cabo Verde",
            "value": "CPV"
          },
          {
            "selected": false,
            "text": "Cameroon",
            "value": "CMR"
          },
          {
            "selected": false,
            "text": "Central African Republic",
            "value": "CAF"
          },
          {
            "selected": false,
            "text": "Chad",
            "value": "TCD"
          },
          {
            "selected": false,
            "text": "Comoros",
            "value": "COM"
          },
          {
            "selected": false,
            "text": "Congo (Republic)",
            "value": "COG"
          },
          {
            "selected": false,
            "text": "Congo (DRC)",
            "value": "COD"
          },
          {
            "selected": false,
            "text": "Djibouti",
            "value": "DJI"
          },
          {
            "selected": false,
            "text": "Egypt",
            "value": "EGY"
          },
          {
            "selected": false,
            "text": "Equatorial Guinea",
            "value": "GNQ"
          },
          {
            "selected": false,
            "text": "Eritrea",
            "value": "ERI"
          },
          {
            "selected": false,
            "text": "Eswatini",
            "value": "SWZ"
          },
          {
            "selected": false,
            "text": "Ethiopia",
            "value": "ETH"
          },
          {
            "selected": false,
            "text": "Gabon",
            "value": "GAB"
          },
          {
            "selected": false,
            "text": "Gambia",
            "value": "GMB"
          },
          {
            "selected": false,
            "text": "Ghana",
            "value": "GHA"
          },
          {
            "selected": false,
            "text": "Guinea",
            "value": "GIN"
          },
          {
            "selected": false,
            "text": "Guinea-Bissau",
            "value": "GNB"
          },
          {
            "selected": false,
            "text": "Cote d'Ivoire",
            "value": "CIV"
          },
          {
            "selected": true,
            "text": "Kenya",
            "value": "KEN"
          },
          {
            "selected": false,
            "text": "Lesotho",
            "value": "LSO"
          },
          {
            "selected": false,
            "text": "Liberia",
            "value": "LBR"
          },
          {
            "selected": false,
            "text": "Libya",
            "value": "LBY"
          },
          {
            "selected": false,
            "text": "Madagascar",
            "value": "MDG"
          },
          {
            "selected": false,
            "text": "Malawi",
            "value": "MWI"
          },
          {
            "selected": false,
            "text": "Mali",
            "value": "MLI"
          },
          {
            "selected": false,
            "text": "Mauritania",
            "value": "MRT"
          },
          {
            "selected": false,
            "text": "Mauritius",
            "value": "MUS"
          },
          {
            "selected": false,
            "text": "Morocco",
            "value": "MAR"
          },
          {
            "selected": false,
            "text": "Mozambique",
            "value": "MOZ"
          },
          {
            "selected": false,
            "text": "Namibia",
            "value": "NAM"
          },
          {
            "selected": false,
            "text": "Niger",
            "value": "NER"
          },
          {
            "selected": false,
            "text": "Nigeria",
            "value": "NGA"
          },
          {
            "selected": false,
            "text": "Rwanda",
            "value": "RWA"
          },
          {
            "selected": false,
            "text": "Sao Tome and Principe",
            "value": "STP"
          },
          {
            "selected": false,
            "text": "Senegal",
            "value": "SEN"
          },
          {
            "selected": false,
            "text": "Seychelles",
            "value": "SYC"
          },
          {
            "selected": false,
            "text": "Sierra Leone",
            "value": "SLE"
          },
          {
            "selected": true,
            "text": "Somalia",
            "value": "SOM"
          },
          {
            "selected": false,
            "text": "South Africa",
            "value": "ZAF"
          },
          {
            "selected": false,
            "text": "South Sudan",
            "value": "SSD"
          },
          {
            "selected": false,
            "text": "Sudan",
            "value": "SDN"
          },
          {
            "selected": false,
            "text": "Tanzania",
            "value": "TZA"
          },
          {
            "selected": false,
            "text": "Togo",
            "value": "TGO"
          },
          {
            "selected": false,
            "text": "Tunisia",
            "value": "TUN"
          },
          {
            "selected": false,
            "text": "Uganda",
            "value": "UGA"
          },
          {
            "selected": false,
            "text": "Zambia",
            "value": "ZMB"
          },
          {
            "selected": false,
            "text": "Zimbabwe",
            "value": "ZWE"
          }
        ],
        "query": "Algeria : DZA, Angola : AGO, Benin : BEN, Botswana : BWA, Burkina Faso : BFA, Burundi : BDI, Cabo Verde : CPV, Cameroon : CMR, Central African Republic : CAF, Chad : TCD, Comoros : COM, Congo (Republic) : COG, Congo (DRC) : COD, Djibouti : DJI, Egypt : EGY, Equatorial Guinea : GNQ, Eritrea : ERI, Eswatini : SWZ, Ethiopia : ETH, Gabon : GAB, Gambia : GMB, Ghana : GHA, Guinea : GIN, Guinea-Bissau : GNB, Cote d'Ivoire : CIV, Kenya : KEN, Lesotho : LSO, Liberia : LBR, Libya : LBY, Madagascar : MDG, Malawi : MWI, Mali : MLI, Mauritania : MRT, Mauritius : MUS, Morocco : MAR, Mozambique : MOZ, Namibia : NAM, Niger : NER, Nigeria : NGA, Rwanda : RWA, Sao Tome and Principe : STP, Senegal : SEN, Seychelles : SYC, Sierra Leone : SLE, Somalia : SOM, South Africa : ZAF, South Sudan : SSD, Sudan : SDN, Tanzania : TZA, Togo : TGO, Tunisia : TUN, Uganda : UGA, Zambia : ZMB, Zimbabwe : ZWE",
        "type": "custom"
      },
      {
        "current": {
          "text": "ADM1",
          "value": "ADM1"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Geo Level",
        "name": "geo_level",
        "options": [
          {
            "selected": true,
            "text": "ADM1",
            "value": "ADM1"
          },
          {
            "selected": false,
            "text": "ADM2",
            "value": "ADM2"
          },
          {
            "selected": false,
            "text": "ADM3",
            "value": "ADM3"
          }
        ],
        "query": "ADM1, ADM2, ADM3",
        "type": "custom"
      },
      {
        "current": {
          "text": "salient",
          "value": "salient"
        },
        "includeAll": false,
        "label": "Forecast",
        "name": "forecast",
        "options": [
          {
            "selected": true,
            "text": "AI-Enhanced NWP",
            "value": "salient"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER",
            "value": "ecmwf_ifs_er"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER Debiased",
            "value": "ecmwf_ifs_er_debiased"
          },
          {
            "selected": false,
            "text": "Clim 1985-2014",
            "value": "climatology_2015"
          },
          {
            "selected": false,
            "text": "Clim + Trend",
            "value": "climatology_trend_2015"
          },
          {
            "selected": false,
            "text": "Clim Rolling",
            "value": "climatology_rolling"
          },
          {
            "selected": false,
            "text": "FuXi",
            "value": "fuxi"
          },
          {
            "selected": false,
            "text": "GraphCast",
            "value": "graphcast"
          },
          {
            "selected": false,
            "text": "GenCast",
            "value": "gencast"
          }
        ],
        "query": "AI-Enhanced NWP : salient, ECMWF IFS ER : ecmwf_ifs_er, ECMWF IFS ER Debiased : ecmwf_ifs_er_debiased, Clim 1985-2014 : climatology_2015, Clim + Trend : climatology_trend_2015, Clim Rolling : climatology_rolling, FuXi : fuxi, GraphCast : graphcast, GenCast : gencast",
        "type": "custom"
      },
      {
        "current": {
          "text": "smape",
          "value": "smape"
        },
        "includeAll": false,
        "label": "Metric",
        "name": "metric",
        "options": [
          {
            "selected": false,
            "text": "MAE",
            "value": "mae"
          },
          {
            "selected": false,
            "text": "CRPS",
            "value": "crps"
          },
          {
            "selected": false,
            "text": "RMSE",
            "value": "rmse"
          },
          {
            "selected": false,
            "text": "ACC",
            "value": "acc"
          },
          {
            "selected": false,
            "text": "Bias",
            "value": "bias"
          },
          {
            "selected": true,
            "text": "SMAPE",
            "value": "smape"
          },
          {
            "selected": false,
            "text": "SEEPS",
            "value": "seeps"
          },
          {
            "selected": false,
            "text": "Heidke (1/5/10/20mm)",
            "value": "heidke-1-5-10-20"
          },
          {
            "selected": false,
            "text": "POD 1mm",
            "value": "pod-1"
          },
          {
            "selected": false,
            "text": "POD 5mm",
            "value": "pod-5"
          },
          {
            "selected": false,
            "text": "POD 10mm",
            "value": "pod-10"
          },
          {
            "selected": false,
            "text": "FAR 1mm",
            "value": "far-1"
          },
          {
            "selected": false,
            "text": "FAR 5mm",
            "value": "far-5"
          },
          {
            "selected": false,
            "text": "FAR 10mm",
            "value": "far-10"
          },
          {
            "selected": false,
            "text": "ETS 1mm",
            "value": "ets-1"
          },
          {
            "selected": false,
            "text": "ETS 5mm",
            "value": "ets-5"
          },
          {
            "selected": false,
            "text": "ETS 10mm",
            "value": "ets-10"
          }
        ],
        "query": "MAE : mae, CRPS : crps, RMSE : rmse, ACC : acc, Bias : bias, SMAPE : smape, SEEPS : seeps, Heidke (1/5/10/20mm) : heidke-1-5-10-20, POD 1mm : pod-1, POD 5mm : pod-5, POD 10mm : pod-10, FAR 1mm : far-1, FAR 5mm : far-5, FAR 10mm : far-10, ETS 1mm : ets-1, ETS 5mm : ets-5, ETS 10mm : ets-10",
        "type": "custom"
      },
      {
        "current": {
          "text": "week1",
          "value": "week1"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Lead",
        "name": "lead",
        "options": [
          {
            "selected": true,
            "text": "Week 1",
            "value": "week1"
          },
          {
            "selected": false,
            "text": "Week 2",
            "value": "week2"
          },
          {
            "selected": false,
            "text": "Week 3",
            "value": "week3"
          },
          {
            "selected": false,
            "text": "Week 4",
            "value": "week4"
          },
          {
            "selected": false,
            "text": "Week 5",
            "value": "week5"
          },
          {
            "selected": false,
            "text": "Week 6",
            "value": "week6"
          }
        ],
        "query": "Week 1 : week1, Week 2 : week2, Week 3 : week3, Week 4 : week4, Week 5 : week5, Week 6 : week6",
        "type": "custom"
      },
      {
        "current": {
          "text": "era5",
          "value": "era5"
        },
        "includeAll": false,
        "label": "Ground Truth",
        "name": "truth",
        "options": [
          {
            "selected": true,
            "text": "ERA5",
            "value": "era5"
          }
        ],
        "query": "ERA5 : era5",
        "type": "custom"
      },
      {
        "current": {
          "text": "global0_25",
          "value": "global0_25"
        },
        "includeAll": false,
        "label": "Grid",
        "name": "grid",
        "options": [
          {
            "selected": false,
            "text": "1.5",
            "value": "global1_5"
          },
          {
            "selected": true,
            "text": "0.25",
            "value": "global0_25"
          }
        ],
        "query": "1.5 : global1_5, 0.25 : global0_25",
        "type": "custom"
      },
      {
        "current": {
          "text": "africa",
          "value": "africa"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Region",
        "name": "region",
        "options": [
          {
            "selected": false,
            "text": "Global",
            "value": "global"
          },
          {
            "selected": true,
            "text": "Africa",
            "value": "africa"
          }
        ],
        "query": " Global : global, Africa : africa",
        "type": "custom"
      },
      {
        "current": {
          "text": "month_of_year",
          "value": "month_of_year"
        },
        "includeAll": false,
        "label": "Time Grouping",
        "name": "time_grouping",
        "options": [
          {
            "selected": false,
            "text": "None",
            "value": "None"
          },
          {
            "selected": true,
            "text": "Month of Year",
            "value": "month_of_year"
          },
          {
            "selected": false,
            "text": "Year",
            "value": "year"
          }
        ],
        "query": "None : None, Month of Year : month_of_year, Year : year",
        "type": "custom"
      },
      {
        "current": {
          "text": "select distinct time from \"78511619b8f3fada8746d000e7f185c6\"",
          "value": "select distinct time from \"78511619b8f3fada8746d000e7f185c6\""
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "8",
          "value": "8"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "${time_filter_filter_query:raw}",
        "includeAll": false,
        "label": "Time Filter",
        "name": "time_filter",
        "options": [],
        "query": "${time_filter_filter_query:raw}",
        "refresh": 1,
        "regex": "",
        "sort": 3,
        "type": "query"
      },
      {
        "current": {
          "text": "where time = 8",
          "value": "where time = 8"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "78511619b8f3fada8746d000e7f185c6",
          "value": "78511619b8f3fada8746d000e7f185c6"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "false",
          "value": "false"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Standardize Forecast Colors",
        "name": "standardize_forecast_colors",
        "options": [
          {
            "selected": true,
            "text": "False",
            "value": "false"
          }
        ],
        "query": "False : false",
        "type": "custom"
      },
      {
        "current": {
          "text": "false",
          "value": "false"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Standardize Lead Colors",
        "name": "standardize_lead_colors",
        "options": [
          {
            "selected": true,
            "text": "False",
            "value": "false"
          }
        ],
        "query": "False : false",
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {
    "hidden": true
  },
  "timezone": "utc",
  "title": "Forecast Evaluation Maps - multihorizon",
  "uid": "bfd145p7u3jlse",
  "version": 1,
  "weekStart": ""
}