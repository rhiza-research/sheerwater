{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "links": [],
  "panels": [
    {
      "datasource": {
        "type": "datasource",
        "uid": "grafana"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 25,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 9,
      "options": {
        "afterRender": "// EXTERNAL({\"panel_id\":\"station-evaluation\",\"key\":\"params\"}):dfd44cgdurwn4f-station-evaluation-params.js\nconst PROTOMAPS_KEY = \"320f86609595a624\";\nconst BASE_STYLE_URL_TEMPLATE =\n    \"https://api.protomaps.com/styles/v5/{flavor}/{lang}.json?key={key}\";\nconst TERRACOTTA_BASE_URL = \"https://terracotta.shared.rhizaresearch.org\";\nconst MAP_CONTAINER_ITEM_CLASS = \"map-container\";\nconst MAP_CONTAINER_ID = \"map-container\";\nconst TERRACOTTA_LAYER_ID = \"terracotta-raster\";\nconst TERRACOTTA_OPACITY = 0.9;\nconst RASTER_CROSSFADE_MS = 220;\nconst RASTER_LOAD_TIMEOUT_MS = 1800;\nconst DEFAULT_FLAVOR = \"black\";\nconst BASE_STYLE_LANG = \"en\";\nconst ALLOWED_SOURCE_LAYERS = [\n    \"boundaries\",\n    \"earth\",\n    \"landcover\",\n    \"places\",\n    \"water\",\n];\nconst MANAGED_OVERLAY_GROUPS = [\n    { key: \"hydroFills\", type: \"fill\", sourceLayer: \"water\" },\n    { key: \"hydroLines\", type: \"line\", sourceLayer: \"water\" },\n    { key: \"adminLines\", type: \"line\", sourceLayer: \"boundaries\" },\n    {\n        key: \"adminBoundaryLabels\",\n        type: \"symbol\",\n        sourceLayer: \"boundaries\",\n    },\n    { key: \"adminAreaLabels\", type: \"symbol\", sourceLayer: \"places\" },\n];\nconst BOUNDARY_CONTRAST = {\n    lineStrokeColor: \"rgba(255,255,255,0.92)\",\n    lineStrokeOpacity: 0.95,\n    lineCasingColor: \"rgba(0,0,0,0.85)\",\n    lineCasingOpacity: 0.9,\n    lineCasingExtraWidth: 1.8,\n    labelTextColor: \"#ffffff\",\n    labelHaloColor: \"#000000\",\n    labelHaloWidth: 1.8,\n    labelHaloBlur: 0.3,\n};\nconst POLL_INTERVAL_MS = 300;\nconst VAR_STABILIZE_MS = 700;\n\nconst replaceVariables =\n    typeof context !== \"undefined\" &&\n        context?.grafana?.replaceVariables &&\n        typeof context.grafana.replaceVariables === \"function\"\n        ? context.grafana.replaceVariables.bind(context.grafana)\n        : (value) => value;\n\nconst readVar = (name, fallback = \"\") => {\n    const token = `\\${${name}}`;\n    const value = replaceVariables(token);\n    if (value === token || value === undefined || value === null || value === \"\") {\n        return fallback;\n    }\n    return value;\n};\n\nfunction resolveMetricProduct(product, truth) {\n    if (typeof product === \"string\" && product.includes(\"_\")) {\n        return product;\n    }\n    const normalizedProduct = (product || \"precip\").trim() || \"precip\";\n    const normalizedTruth = (truth || \"era5\").trim() || \"era5\";\n    return `${normalizedTruth}_${normalizedProduct}`;\n}\n\nconst readVars = () => {\n    const truth = readVar(\"truth\", \"ghcn\");\n    const product = readVar(\"product\", \"precip\");\n    return {\n        forecast: readVar(\"reanalysis\", \"era5\"),\n        grid: readVar(\"grid\"),\n        metric: readVar(\"metric\", \"mae\"),\n        product: resolveMetricProduct(product, truth),\n        lead: readVar(\"lead\", \"week1\"),\n        timeGrouping: readVar(\"time_grouping\"),\n        timeFilter: readVar(\"time_filter\", \"None\"),\n        aggDays: readVar(\"agg_days\", \"7\"),\n        datasetFamily: \"metric\",\n    };\n};\n\nfunction resolveRegion(_) {\n    return \"global\";\n}\n\nlet VARS = readVars();\nlet stretchRequestController = null;\nlet maplibreReady = null;\n// EXTERNAL:maplibre-map-builder.js\nfunction buildStyleUrl(flavor) {\n    return BASE_STYLE_URL_TEMPLATE.replace(\"{flavor}\", flavor)\n        .replace(\"{lang}\", BASE_STYLE_LANG)\n        .replace(\"{key}\", PROTOMAPS_KEY);\n}\n\nasync function fetchPreparedStyle(flavor) {\n    const response = await fetch(buildStyleUrl(flavor));\n    if (!response.ok) {\n        throw new Error(`Style request failed (${response.status}).`);\n    }\n    const rawStyle = await response.json();\n    return prepareStyle(rawStyle);\n}\n\nfunction prepareStyle(styleJson) {\n    const allowedSourceLayers = new Set(ALLOWED_SOURCE_LAYERS);\n    const filteredLayers = (styleJson.layers || [])\n        .filter((layer) => {\n            const sourceLayer = layer[\"source-layer\"];\n            if (!sourceLayer) {\n                return true;\n            }\n            return (\n                allowedSourceLayers.size === 0 ||\n                allowedSourceLayers.has(sourceLayer)\n            );\n        })\n        .map((layer) => {\n            if (layer.type !== \"fill\" || layer[\"source-layer\"] !== \"water\") {\n                return layer;\n            }\n            return {\n                ...layer,\n                paint: {\n                    ...(layer.paint || {}),\n                    \"fill-opacity\": 0.8,\n                },\n            };\n        });\n\n    return {\n        ...styleJson,\n        layers: filteredLayers,\n        sprite: `https://protomaps.github.io/basemaps-assets/sprites/v4/${DEFAULT_FLAVOR}`,\n    };\n}\n\nfunction getGroupedManagedLayers(map) {\n    if (!map || !map.getStyle) {\n        return {};\n    }\n    const style = map.getStyle();\n    const groups = {};\n    const claimed = new Set();\n    MANAGED_OVERLAY_GROUPS.forEach((group) => {\n        groups[group.key] = [];\n        (style.layers || []).forEach((layer) => {\n            if (claimed.has(layer.id)) {\n                return;\n            }\n            if (\n                layer.type === group.type &&\n                layer[\"source-layer\"] === group.sourceLayer\n            ) {\n                groups[group.key].push(layer.id);\n                claimed.add(layer.id);\n            }\n        });\n    });\n    return groups;\n}\n\nfunction getManagedLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return MANAGED_OVERLAY_GROUPS.flatMap((group) => grouped[group.key] || []);\n}\n\nfunction getAdminBoundaryLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return grouped.adminLines || [];\n}\n\nfunction getBoundaryLabelLayerIds(map) {\n    const grouped = getGroupedManagedLayers(map);\n    return [...(grouped.adminBoundaryLabels || []), ...(grouped.adminAreaLabels || [])];\n}\n\nfunction applyBoundaryLineContrast(map, layerId) {\n    if (!map || !map.getLayer(layerId)) {\n        return;\n    }\n    const style = map.getStyle();\n    const layerDef = (style.layers || []).find((layer) => layer.id === layerId);\n    if (!layerDef) {\n        return;\n    }\n    const basePaint = layerDef.paint || {};\n    const baseWidth = basePaint[\"line-width\"] ?? 1;\n    const casingLayerId = `${layerId}__contrast_casing`;\n    if (map.getLayer(casingLayerId)) {\n        map.removeLayer(casingLayerId);\n    }\n\n    const casingPaint = {\n        ...basePaint,\n        \"line-color\": BOUNDARY_CONTRAST.lineCasingColor,\n        \"line-opacity\": BOUNDARY_CONTRAST.lineCasingOpacity,\n        \"line-width\": [\"+\", baseWidth, BOUNDARY_CONTRAST.lineCasingExtraWidth],\n    };\n\n    try {\n        map.addLayer(\n            {\n                ...layerDef,\n                id: casingLayerId,\n                paint: casingPaint,\n            },\n            layerId\n        );\n    } catch (error) {\n        console.warn(`Failed to add contrast casing for ${layerId}:`, error);\n    }\n\n    map.setPaintProperty(layerId, \"line-color\", BOUNDARY_CONTRAST.lineStrokeColor);\n    map.setPaintProperty(\n        layerId,\n        \"line-opacity\",\n        BOUNDARY_CONTRAST.lineStrokeOpacity\n    );\n}\n\nfunction applyBoundaryLabelContrast(map, layerId) {\n    if (!map || !map.getLayer(layerId)) {\n        return;\n    }\n    map.setPaintProperty(layerId, \"text-color\", BOUNDARY_CONTRAST.labelTextColor);\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-color\",\n        BOUNDARY_CONTRAST.labelHaloColor\n    );\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-width\",\n        BOUNDARY_CONTRAST.labelHaloWidth\n    );\n    map.setPaintProperty(\n        layerId,\n        \"text-halo-blur\",\n        BOUNDARY_CONTRAST.labelHaloBlur\n    );\n}\n\nfunction applyBoundaryContrastOverrides(map) {\n    getAdminBoundaryLayerIds(map).forEach((layerId) => {\n        applyBoundaryLineContrast(map, layerId);\n    });\n    getBoundaryLabelLayerIds(map).forEach((layerId) => {\n        applyBoundaryLabelContrast(map, layerId);\n    });\n}\n\nfunction applyManagedOverlayLayerOrder(map) {\n    getManagedLayerIds(map).forEach((layerId) => {\n        if (!map.getLayer(layerId)) {\n            return;\n        }\n        try {\n            map.moveLayer(layerId);\n        } catch (error) {\n            console.warn(`Failed to move managed layer ${layerId}:`, error);\n        }\n    });\n}\n\nfunction getRasterInsertBeforeId(map) {\n    return getManagedLayerIds(map).find((layerId) => map.getLayer(layerId)) || null;\n}\n\nfunction getRasterSlotId(slot) {\n    return `${TERRACOTTA_LAYER_ID}-${slot}`;\n}\n\nfunction removeRasterSlot(map, slot) {\n    const slotId = getRasterSlotId(slot);\n    if (map.getLayer(slotId)) {\n        map.removeLayer(slotId);\n    }\n    if (map.getSource(slotId)) {\n        map.removeSource(slotId);\n    }\n}\n\nfunction setRasterLayer(map, tileUrl, slot = 0, opacity = TERRACOTTA_OPACITY) {\n    if (!map || !tileUrl) {\n        return;\n    }\n    const slotId = getRasterSlotId(slot);\n    removeRasterSlot(map, slot);\n\n    map.addSource(slotId, {\n        type: \"raster\",\n        tiles: [tileUrl],\n        tileSize: 256,\n    });\n\n    const layerDefinition = {\n        id: slotId,\n        type: \"raster\",\n        source: slotId,\n        paint: {\n            \"raster-opacity\": opacity,\n            \"raster-fade-duration\": 0,\n        },\n    };\n    const beforeLayerId = getRasterInsertBeforeId(map);\n    if (beforeLayerId) {\n        map.addLayer(layerDefinition, beforeLayerId);\n    } else {\n        map.addLayer(layerDefinition);\n    }\n    applyManagedOverlayLayerOrder(map);\n    return slotId;\n}\n\nfunction fadeRasterOpacity(map, layerId, fromOpacity, toOpacity, durationMs) {\n    if (!map.getLayer(layerId)) {\n        return Promise.resolve();\n    }\n    const clampOpacity = (value) => Math.max(0, Math.min(1, Number(value) || 0));\n    const safeFromOpacity = clampOpacity(fromOpacity);\n    const safeToOpacity = clampOpacity(toOpacity);\n    if (durationMs <= 0 || fromOpacity === toOpacity) {\n        map.setPaintProperty(layerId, \"raster-opacity\", safeToOpacity);\n        return Promise.resolve();\n    }\n    const start = performance.now();\n    return new Promise((resolve) => {\n        const step = (now) => {\n            if (!map.getLayer(layerId)) {\n                resolve();\n                return;\n            }\n            const t = Math.max(0, Math.min(1, (now - start) / durationMs));\n            const current = safeFromOpacity + (safeToOpacity - safeFromOpacity) * t;\n            map.setPaintProperty(layerId, \"raster-opacity\", clampOpacity(current));\n            if (t >= 1) {\n                resolve();\n                return;\n            }\n            requestAnimationFrame(step);\n        };\n        requestAnimationFrame(step);\n    });\n}\n\nasync function swapRasterLayer(runtime, tileUrl) {\n    const map = runtime?.map;\n    if (!map || !tileUrl) {\n        return;\n    }\n    const oldSlot = runtime.rasterSlot ?? 0;\n    const nextSlot = oldSlot === 0 ? 1 : 0;\n    const nextSlotId = setRasterLayer(map, tileUrl, nextSlot, 0);\n    const oldSlotId = getRasterSlotId(oldSlot);\n    const swapToken = (runtime.rasterSwapToken || 0) + 1;\n    runtime.rasterSwapToken = swapToken;\n\n    await new Promise((resolve) => {\n        let settled = false;\n        const finish = () => {\n            if (settled) {\n                return;\n            }\n            settled = true;\n            map.off(\"sourcedata\", onSourceData);\n            resolve();\n        };\n        const onSourceData = (event) => {\n            if (event.sourceId !== nextSlotId) {\n                return;\n            }\n            if (map.isSourceLoaded(nextSlotId)) {\n                finish();\n            }\n        };\n        map.on(\"sourcedata\", onSourceData);\n        window.setTimeout(finish, RASTER_LOAD_TIMEOUT_MS);\n    });\n\n    if (runtime.rasterSwapToken !== swapToken) {\n        return;\n    }\n\n    await Promise.all([\n        fadeRasterOpacity(\n            map,\n            nextSlotId,\n            0,\n            TERRACOTTA_OPACITY,\n            RASTER_CROSSFADE_MS\n        ),\n        fadeRasterOpacity(\n            map,\n            oldSlotId,\n            TERRACOTTA_OPACITY,\n            0,\n            RASTER_CROSSFADE_MS\n        ),\n    ]);\n\n    removeRasterSlot(map, oldSlot);\n    runtime.rasterSlot = nextSlot;\n}\n\nfunction getMaplibreGlobal() {\n    if (globalThis && globalThis.maplibregl) {\n        return globalThis.maplibregl;\n    }\n    if (window.maplibregl) {\n        return window.maplibregl;\n    }\n    if (window.parent && window.parent.maplibregl) {\n        return window.parent.maplibregl;\n    }\n    if (window.top && window.top.maplibregl) {\n        return window.top.maplibregl;\n    }\n    return null;\n}\n\nfunction waitForMaplibreGlobal(timeoutMs = 4000) {\n    return new Promise((resolve, reject) => {\n        if (getMaplibreGlobal()) {\n            resolve();\n            return;\n        }\n        const start = Date.now();\n        const tick = () => {\n            if (getMaplibreGlobal()) {\n                resolve();\n                return;\n            }\n            if (Date.now() - start > timeoutMs) {\n                reject(new Error(\"maplibregl global not available\"));\n                return;\n            }\n            window.setTimeout(tick, 50);\n        };\n        tick();\n    });\n}\n\nfunction loadMaplibre() {\n    if (getMaplibreGlobal()) {\n        return Promise.resolve();\n    }\n    if (maplibreReady) {\n        return maplibreReady;\n    }\n    maplibreReady = new Promise((resolve, reject) => {\n        const script = document.createElement(\"script\");\n        script.src = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js\";\n        script.crossOrigin = \"anonymous\";\n        script.onload = () => {\n            waitForMaplibreGlobal()\n                .then(() => {\n                    const global = getMaplibreGlobal();\n                    if (global && !window.maplibregl) {\n                        window.maplibregl = global;\n                    }\n                    resolve();\n                })\n                .catch(() => {\n                    import(\"https://esm.sh/maplibre-gl@3.6.2\")\n                        .then((module) => {\n                            window.maplibregl = module.default || module;\n                            return waitForMaplibreGlobal();\n                        })\n                        .then(resolve)\n                        .catch((error) => {\n                            reject(\n                                new Error(\n                                    `Failed to load maplibre-gl (global + esm). ${error}`\n                                )\n                            );\n                        });\n                });\n        };\n        script.onerror = () => {\n            import(\"https://esm.sh/maplibre-gl@3.6.2\")\n                .then((module) => {\n                    window.maplibregl = module.default || module;\n                    return waitForMaplibreGlobal();\n                })\n                .then(resolve)\n                .catch((error) => {\n                    reject(\n                        new Error(\n                            `Failed to load maplibre-gl.js and esm import. ${error}`\n                        )\n                    );\n                });\n        };\n        document.head.appendChild(script);\n    });\n    return maplibreReady;\n}\n\nfunction injectContainerAndStyles() {\n    const mapMountId = `${MAP_CONTAINER_ID}__mount`;\n    const existing = getOrCreateHostContainer();\n    if (existing.querySelector(`#${mapMountId}`)) {\n        const existingMount = document.getElementById(mapMountId);\n        return existingMount;\n    }\n\n    const style = document.createElement(\"style\");\n    style.textContent = `\n    :root {\n    --ink:#0c1f2e;\n    --panel:#f5f3ef;\n    }\n      .map-shell {\n        position:relative;\n        width:100%;\n        height:70vh;\n        min-height:60vh;\n    font-family:\"IBM Plex Sans\", \"Segoe UI\", sans-serif;\n    border-radius:18px;\n    overflow:hidden;\n    box-shadow:0 16px 40px rgba(8, 16, 28, 0.25);\n    border:1px solid rgba(12, 31, 46, 0.2);\n    background:#0b1220;\n    }\n      .map-mount {\n        position:absolute;\n        inset:0;\n        width:100%;\n        height:100%;\n      }\n    .maplibregl-canvas {\n    width:100% !important;\n    height:100% !important;\n    }\n    #map-colorscale {\n    position:absolute;\n    left:14px;\n    bottom:14px;\n    z-index:4;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    pointer-events:none;\n    background:rgba(245, 243, 239, 0.96);\n    color:var(--ink);\n    padding:4px 8px;\n    border-radius:10px;\n    border:1px solid rgba(12, 31, 46, 0.18);\n    font-size:11px;\n    line-height:1.2;\n    min-height:22px;\n    white-space:nowrap;\n    box-shadow:0 12px 24px rgba(8, 16, 28, 0.15);\n    }\n`;\n    document.head.appendChild(style);\n\n    const hostContainer = getOrCreateHostContainer();\n\n    hostContainer.innerHTML = `\n      <div class=\"map-shell\" id=\"map-shell-main\">\n        <div id=\"${mapMountId}\" class=\"map-mount\"></div>\n        <div id=\"map-colorscale\"></div>\n      </div>\n    `;\n\n    const css = document.createElement(\"link\");\n    css.rel = \"stylesheet\";\n    css.href = \"https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css\";\n    document.head.appendChild(css);\n\n    loadMaplibre();\n    return document.getElementById(mapMountId);\n}\n\nfunction createSingleMapInstance(container, baseStyle) {\n    const mapContainer =\n        container || document.getElementById(`${MAP_CONTAINER_ID}__mount`) || MAP_CONTAINER_ID;\n    const fullscreenContainer =\n        typeof mapContainer?.closest === \"function\"\n            ? mapContainer.closest(\".map-shell\")\n            : document.getElementById(\"map-shell-main\");\n    function forceCompactAttribution(mapInstance) {\n        if (!mapInstance || !mapInstance.getContainer) return;\n        const root = mapInstance.getContainer();\n        const attributions = root.querySelectorAll(\".maplibregl-ctrl-attrib\");\n        attributions.forEach((control) => {\n            control.classList.add(\"maplibregl-compact\");\n            control.classList.remove(\"maplibregl-compact-show\");\n        });\n    }\n    const map = new window.maplibregl.Map({\n        container: mapContainer,\n        style: baseStyle,\n        center: [0, 20],\n        zoom: 1.2,\n        attributionControl: false,\n        cooperativeGestures: false,\n    });\n\n    map.addControl(\n        new window.maplibregl.NavigationControl({ showCompass: false })\n    );\n    map.addControl(\n        new window.maplibregl.FullscreenControl(\n            fullscreenContainer ? { container: fullscreenContainer } : {}\n        ),\n        \"top-right\"\n    );\n    map.addControl(\n        new window.maplibregl.AttributionControl({ compact: true })\n    );\n    map.on(\"load\", () => forceCompactAttribution(map));\n    window.setTimeout(() => forceCompactAttribution(map), 0);\n\n    return map;\n}\n// EXTERNAL:color_utilities.js\nfunction getColorStops(colormap) {\n    const palette = colormap.endsWith(\"_r\") ? colormap.slice(0, -2) : colormap;\n    const paletteStops = {\n        brbg: [\n            \"#543005\",\n            \"#8c510a\",\n            \"#bf812d\",\n            \"#dfc27d\",\n            \"#f6e8c3\",\n            \"#f5f5f5\",\n            \"#c7eae5\",\n            \"#80cdc1\",\n            \"#35978f\",\n            \"#01665e\",\n            \"#003c30\",\n        ],\n        rdbu: [\n            \"#67001f\",\n            \"#b2182b\",\n            \"#d6604d\",\n            \"#f4a582\",\n            \"#fddbc7\",\n            \"#f7f7f7\",\n            \"#d1e5f0\",\n            \"#92c5de\",\n            \"#4393c3\",\n            \"#2166ac\",\n            \"#053061\",\n        ],\n        reds: [\n            \"#fff5f0\",\n            \"#fee0d2\",\n            \"#fcbba1\",\n            \"#fc9272\",\n            \"#fb6a4a\",\n            \"#ef3b2c\",\n            \"#cb181d\",\n            \"#a50f15\",\n            \"#67000d\",\n        ],\n    };\n    const stops = paletteStops[palette] || paletteStops.reds;\n    return colormap.endsWith(\"_r\") ? [...stops].reverse() : stops;\n}\n\nfunction renderColorScaleHtml(stretch) {\n    if (!stretch) {\n        return \"<span>No stretch</span>\";\n    }\n    const decoded = decodeURIComponent(stretch);\n    const colormapMatch = decoded.match(/colormap=([^&]+)/);\n    const rangeMatch = decoded.match(/stretch_range=\\[([^\\]]+)\\]/);\n    const colormap = colormapMatch ? colormapMatch[1] : \"\";\n    let min = \"min\";\n    let max = \"max\";\n    if (rangeMatch) {\n        const parts = rangeMatch[1].split(\",\").map((value) => Number(value.trim()));\n        if (parts.length >= 2) {\n            min = parts[0].toFixed(1);\n            max = parts[1].toFixed(1);\n        }\n    }\n    const stops = getColorStops(colormap);\n    const gradient = `linear-gradient(90deg, ${stops.join(\", \")})`;\n    return `\n      <div style=\"display:flex; align-items:center; height:100%; gap:6px; font-variant-numeric:tabular-nums;\">\n        <span>${min}</span>\n        <div style=\"width:72px; height:8px; border-radius:999px; background:${gradient};\"></div>\n        <span>${max}</span>\n      </div>\n    `;\n}\n\nfunction refreshColorScale(stretch) {\n    const scale = document.getElementById(\"map-colorscale\");\n    if (!scale) {\n        return;\n    }\n    scale.innerHTML = renderColorScaleHtml(stretch);\n}\n// EXTERNAL:terracotta_dataset_utilities.js\nfunction buildDatasetId(params) {\n    const datasetFamily = params?.datasetFamily || \"grouped_metric\";\n    const { startDate, endDate } = resolveDatasetDates(datasetFamily);\n    const timeSuffix =\n        params.timeFilter && params.timeFilter !== \"None\" ? `_${params.timeFilter}` : \"\";\n\n    if (datasetFamily === \"metric\") {\n        const aggDays = String(params?.aggDays || \"7\");\n        const { truth, category } = splitProduct(params?.product);\n        return (\n            [\n                \"metric\",\n                aggDays,\n                endDate,\n                params.forecast,\n                params.grid,\n                \"lsm\",\n                params.metric,\n                \"global\",\n                \"None\",\n                \"True\",\n                startDate,\n                params.timeGrouping,\n                truth,\n                category,\n            ].join(\"_\") + timeSuffix\n        );\n    }\n\n    return (\n        `grouped_metric_${endDate}_` +\n        `${params.forecast}_${params.grid}_${params.lead}_lsm_${params.metric}_` +\n        `${params.region}_True_${startDate}_${params.timeGrouping}_${params.product}` +\n        timeSuffix\n    );\n}\n\nfunction resolveDatasetDates(datasetFamily) {\n    if (datasetFamily === \"metric\") {\n        return { startDate: \"1998-01-01\", endDate: \"2024-12-31\" };\n    }\n    return { startDate: \"2016-01-01\", endDate: \"2022-12-31\" };\n}\n\nfunction splitProduct(product) {\n    const raw = String(product || \"\");\n    const firstUnderscore = raw.indexOf(\"_\");\n    if (firstUnderscore > 0 && firstUnderscore < raw.length - 1) {\n        return {\n            truth: raw.slice(0, firstUnderscore),\n            category: raw.slice(firstUnderscore + 1),\n        };\n    }\n    return { truth: \"era5\", category: raw || \"precip\" };\n}\n\nfunction extractPercentileBounds(metadata) {\n    const percentiles = metadata?.percentiles || [];\n    if (percentiles.length < 95) {\n        return null;\n    }\n    return [percentiles[4], percentiles[94]];\n}\n\nfunction buildStretchFromBounds(colorMin, colorMax, metric, product) {\n    let colormap = \"reds\";\n    if (metric === \"bias\") {\n        if (Math.abs(colorMin) > colorMax) {\n            colorMax = Math.abs(colorMin);\n        } else {\n            colorMin = colorMax * -1;\n        }\n        colormap = product === \"era5_tmp2m\" ? \"rdbu_r\" : \"brbg\";\n    } else if (metric === \"acc\") {\n        colorMin = -1;\n        colorMax = 1;\n        colormap = \"rdbu\";\n    } else if (metric === \"seeps\") {\n        colorMin = 0;\n        colorMax = 2.0;\n        colormap = \"reds\";\n    }\n\n    return `colormap=${colormap}&stretch_range=[${colorMin},${colorMax}]`;\n}\n\nfunction computeStretch(metadata, metric, product) {\n    const bounds = extractPercentileBounds(metadata);\n    if (!bounds) {\n        return \"\";\n    }\n    return buildStretchFromBounds(bounds[0], bounds[1], metric, product);\n}\n\nfunction computeSharedStretchFromMetadata(metadataList, metric, product) {\n    const bounds = (metadataList || [])\n        .map((metadata) => extractPercentileBounds(metadata))\n        .filter((item) => Array.isArray(item));\n    if (!bounds.length) {\n        return \"\";\n    }\n    const colorMin = Math.min(...bounds.map((item) => item[0]));\n    const colorMax = Math.max(...bounds.map((item) => item[1]));\n    return buildStretchFromBounds(colorMin, colorMax, metric, product);\n}\n\nasync function fetchMetadata(params, signal) {\n    const datasetId = buildDatasetId(params);\n    const url = `${TERRACOTTA_BASE_URL}/metadata/${encodeURIComponent(datasetId)}`;\n    const response = await fetch(url, signal ? { signal } : undefined);\n    if (!response.ok) {\n        const error = new Error(`Metadata request failed (${response.status})`);\n        error.status = response.status;\n        throw error;\n    }\n    return response.json();\n}\n\nasync function fetchStretch(params, signal) {\n    const metadata = await fetchMetadata(params, signal);\n    return computeStretch(metadata, params.metric, params.product);\n}\n\nfunction buildTileUrl(params, stretch) {\n    const datasetId = buildDatasetId(params);\n    const base = `${TERRACOTTA_BASE_URL}/singleband/${encodeURIComponent(datasetId)}/{z}/{x}/{y}.png`;\n    if (!stretch) {\n        return { datasetId, tileUrl: base };\n    }\n    const query = encodeURIComponent(stretch)\n        .replace(/%26/g, \"&\")\n        .replace(/%3D/g, \"=\");\n    return { datasetId, tileUrl: `${base}?${query}` };\n}\n// EXTERNAL:maplibre-singlemap-orchestration.js\n\nfunction getPanelRoot() {\n    return (\n        document.querySelector(\"#panel-content\") ||\n        document.querySelector(\".panel-content\") ||\n        document.querySelector(\".panel-content--no-padding\") ||\n        document.querySelector(\".panel-container\") ||\n        document.body\n    );\n}\n\nfunction getOrCreateHostContainer() {\n    const existing = document.getElementById(MAP_CONTAINER_ID);\n    if (existing) {\n        return existing;\n    }\n    const host = document.createElement(\"div\");\n    host.id = MAP_CONTAINER_ID;\n    host.className = MAP_CONTAINER_ITEM_CLASS;\n    getPanelRoot().appendChild(host);\n    return host;\n}\n\nasync function initCurrentMapPage() {\n    const container = injectContainerAndStyles();\n    try {\n        await loadMaplibre();\n    } catch (error) {\n        console.error(\"MapLibre failed to load.\", error);\n        return;\n    }\n\n    if (!getMaplibreGlobal()) {\n        console.error(\"MapLibre is unavailable after load.\");\n        return;\n    }\n    if (!window.maplibregl && getMaplibreGlobal()) {\n        window.maplibregl = getMaplibreGlobal();\n    }\n\n    const params = {\n        ...VARS,\n        region: resolveRegion(VARS.forecast),\n    };\n\n    let stretch = \"\";\n    try {\n        stretch = await fetchStretch(params);\n    } catch (error) {\n        console.error(\"Failed to fetch stretch\", error);\n    }\n    refreshColorScale(stretch);\n\n    const { datasetId, tileUrl } = buildTileUrl(params, stretch);\n    let baseStyle = null;\n    try {\n        baseStyle = await fetchPreparedStyle(DEFAULT_FLAVOR);\n    } catch (error) {\n        console.error(\"Failed to fetch prepared style\", error);\n        return;\n    }\n\n    const existingRuntime = window.__grafanaMaplibre;\n    if (existingRuntime?.pollHandle) {\n        window.clearInterval(existingRuntime.pollHandle);\n    }\n    if (existingRuntime && existingRuntime.map) {\n        try {\n            existingRuntime.map.remove();\n        } catch (error) {\n            console.warn(\"Failed to remove existing map\", error);\n        }\n    }\n\n    const map = createSingleMapInstance(container, baseStyle);\n\n    window.__grafanaMaplibre = {\n        map,\n        datasetId,\n        tileUrl,\n        stretch,\n        params,\n        rasterSlot: 0,\n        rasterSwapToken: 0,\n        ready: false,\n    };\n\n    map.on(\"load\", () => {\n        window.__grafanaMaplibre.ready = true;\n        applyBoundaryContrastOverrides(map);\n        setRasterLayer(map, tileUrl, 0, TERRACOTTA_OPACITY);\n        removeRasterSlot(map, 1);\n    });\n\n    let pendingVars = null;\n    let pendingSince = 0;\n    let refreshToken = 0;\n\n    window.__grafanaMaplibre.pollHandle = window.setInterval(async () => {\n        if (!window.__grafanaMaplibre?.ready) {\n            return;\n        }\n\n        const observedVars = readVars();\n        const observedSig = JSON.stringify(observedVars);\n        const currentSig = JSON.stringify(VARS);\n        if (observedSig === currentSig) {\n            pendingVars = null;\n            pendingSince = 0;\n            return;\n        }\n\n        if (!pendingVars || JSON.stringify(pendingVars) !== observedSig) {\n            pendingVars = observedVars;\n            pendingSince = Date.now();\n            return;\n        }\n\n        if (Date.now() - pendingSince < VAR_STABILIZE_MS) {\n            return;\n        }\n\n        VARS = pendingVars;\n        pendingVars = null;\n        pendingSince = 0;\n        const nextParams = {\n            ...VARS,\n            region: resolveRegion(VARS.forecast),\n        };\n\n        if (stretchRequestController) {\n            stretchRequestController.abort();\n        }\n        stretchRequestController = new AbortController();\n        const token = ++refreshToken;\n\n        let nextStretch = \"\";\n        try {\n            nextStretch = await fetchStretch(\n                nextParams,\n                stretchRequestController.signal\n            );\n        } catch (error) {\n            if (error?.name === \"AbortError\") {\n                return;\n            }\n            console.error(\"Failed to fetch stretch\", error);\n        }\n        if (token !== refreshToken) {\n            return;\n        }\n\n        const next = buildTileUrl(nextParams, nextStretch);\n        if (nextStretch !== window.__grafanaMaplibre.stretch) {\n            refreshColorScale(nextStretch);\n        }\n\n        if (next.tileUrl !== window.__grafanaMaplibre.tileUrl) {\n            await swapRasterLayer(window.__grafanaMaplibre, next.tileUrl);\n        }\n\n        window.__grafanaMaplibre.datasetId = next.datasetId;\n        window.__grafanaMaplibre.tileUrl = next.tileUrl;\n        window.__grafanaMaplibre.stretch = nextStretch;\n        window.__grafanaMaplibre.params = nextParams;\n    }, POLL_INTERVAL_MS);\n}\n// EXTERNAL:maplibre-multimap-orchestration.js\n\nfunction ensureRuntimeContainer() {\n    const existingRuntime = window.__grafanaMaplibreMultimap;\n    if (existingRuntime?.pollHandle) {\n        window.clearInterval(existingRuntime.pollHandle);\n    }\n    if (existingRuntime?.cells) {\n        existingRuntime.cells.forEach((cellRuntime) => {\n            if (cellRuntime?.map) {\n                try {\n                    cellRuntime.map.remove();\n                } catch (error) {\n                    console.warn(\"Failed to remove existing multimap map\", error);\n                }\n            }\n        });\n    }\n}\n\nfunction applyManualSync(maps) {\n    let syncing = false;\n    const syncFrom = (sourceMap) => {\n        if (syncing) {\n            return;\n        }\n        syncing = true;\n        const center = sourceMap.getCenter();\n        const zoom = sourceMap.getZoom();\n        const bearing = sourceMap.getBearing();\n        const pitch = sourceMap.getPitch();\n\n        maps.forEach((map) => {\n            if (map === sourceMap) {\n                return;\n            }\n            map.jumpTo({ center, zoom, bearing, pitch });\n        });\n        syncing = false;\n    };\n\n    maps.forEach((map) => {\n        map.on(\"moveend\", () => syncFrom(map));\n        map.on(\"zoomend\", () => syncFrom(map));\n        map.on(\"dragend\", () => syncFrom(map));\n    });\n}\n\nfunction loadSyncMovePlugin() {\n    if (window.syncMaps && typeof window.syncMaps === \"function\") {\n        return Promise.resolve();\n    }\n    if (syncMoveReady) {\n        return syncMoveReady;\n    }\n\n    syncMoveReady = new Promise((resolve) => {\n        const script = document.createElement(\"script\");\n        script.src = \"https://unpkg.com/mapbox-gl-sync-move@0.3.1/index.js\";\n        script.onload = () => resolve();\n        script.onerror = () => resolve();\n        document.head.appendChild(script);\n    });\n\n    return syncMoveReady;\n}\n\nasync function synchronizeMaps(cellRuntimes) {\n    const maps = cellRuntimes.map((runtime) => runtime.map).filter(Boolean);\n    if (maps.length < 2) {\n        return;\n    }\n\n    await loadSyncMovePlugin();\n    if (window.syncMaps && typeof window.syncMaps === \"function\") {\n        try {\n            window.syncMaps(...maps);\n            return;\n        } catch (error) {\n            console.warn(\"syncMaps plugin failed, using fallback sync\", error);\n        }\n    }\n    applyManualSync(maps);\n}\n\nfunction buildCellParams(vars, cellDef) {\n    return {\n        forecast: vars.forecast,\n        grid: vars.grid,\n        metric: vars.metric,\n        product: cellDef.productValue,\n        lead: `week${cellDef.week}`,\n        timeGrouping: vars.timeGrouping,\n        timeFilter: vars.timeFilter,\n        region: resolveRegion(vars.forecast),\n    };\n}\n\nfunction setProductRowVisibility(productKey, visible) {\n    const row = document.getElementById(`bt-multimap-row-${productKey}`);\n    if (!row) {\n        return;\n    }\n    row.style.display = visible ? \"\" : \"none\";\n}\n\nasync function refreshAllCells(runtime, vars) {\n    if (stretchRequestController) {\n        stretchRequestController.abort();\n    }\n    stretchRequestController = new AbortController();\n    const signal = stretchRequestController.signal;\n    const token = (runtime.refreshToken || 0) + 1;\n    runtime.refreshToken = token;\n\n    const metadataResults = await Promise.all(\n        runtime.cells.map(async (cellRuntime) => {\n            const nextParams = buildCellParams(vars, cellRuntime.def);\n            let metadata = null;\n            try {\n                metadata = await fetchMetadata(nextParams, signal);\n            } catch (error) {\n                if (error?.name !== \"AbortError\" && error?.status !== 404) {\n                    console.error(\"Failed to fetch metadata\", error);\n                }\n            }\n            return {\n                key: cellRuntime.def.key,\n                productKey: cellRuntime.def.productKey,\n                params: nextParams,\n                metadata,\n            };\n        })\n    );\n\n    if (runtime.refreshToken !== token) {\n        return;\n    }\n\n    const scaleByProduct = {};\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const leadMetadata = metadataResults\n            .filter(\n                (result) =>\n                    result.productKey === product.key && result.metadata !== null\n            )\n            .map((result) => result.metadata);\n        scaleByProduct[product.key] = computeSharedStretchFromMetadata(\n            leadMetadata,\n            vars.metric,\n            product.product\n        );\n    });\n\n    MULTIMAP_PRODUCTS.forEach((product) => {\n        const hasStretch = Boolean(scaleByProduct[product.key]);\n        setProductRowVisibility(product.key, hasStretch);\n        const scaleMarkup = renderColorScaleHtml(scaleByProduct[product.key] || \"\");\n        const rowScaleEl = document.getElementById(\n            `bt-multimap-row-scale-${product.key}`\n        );\n        if (rowScaleEl) {\n            rowScaleEl.innerHTML = scaleMarkup;\n        }\n        const scaleEls = document.querySelectorAll(\n            `.bt-multimap-map-scale[data-product-key=\"${product.key}\"]`\n        );\n        scaleEls.forEach((scaleEl) => {\n            scaleEl.innerHTML = scaleMarkup;\n        });\n    });\n\n    const results = metadataResults.map((result) => {\n        const sharedStretch = scaleByProduct[result.productKey] || \"\";\n        if (!sharedStretch) {\n            return {\n                ...result,\n                stretch: \"\",\n                datasetId: buildDatasetId(result.params),\n                tileUrl: \"\",\n            };\n        }\n        if (result.metadata === null) {\n            return {\n                ...result,\n                stretch: sharedStretch,\n                datasetId: buildDatasetId(result.params),\n                tileUrl: \"\",\n            };\n        }\n        const next = buildTileUrl(result.params, sharedStretch);\n        return {\n            ...result,\n            stretch: sharedStretch,\n            datasetId: next.datasetId,\n            tileUrl: next.tileUrl,\n        };\n    });\n\n    for (const result of results) {\n        const cellRuntime = runtime.cellsByKey.get(result.key);\n        if (!cellRuntime) {\n            continue;\n        }\n\n        const previousTileUrl = cellRuntime.tileUrl;\n        cellRuntime.params = result.params;\n        cellRuntime.stretch = result.stretch;\n        cellRuntime.datasetId = result.datasetId;\n        cellRuntime.tileUrl = result.tileUrl;\n\n        if (!cellRuntime.ready) {\n            continue;\n        }\n\n        if (!result.tileUrl) {\n            removeRasterSlot(cellRuntime.map, 0);\n            removeRasterSlot(cellRuntime.map, 1);\n            continue;\n        }\n\n        if (!previousTileUrl) {\n            setRasterLayer(cellRuntime.map, result.tileUrl, 0, TERRACOTTA_OPACITY);\n            removeRasterSlot(cellRuntime.map, 1);\n            continue;\n        }\n\n        if (previousTileUrl !== result.tileUrl) {\n            await swapRasterLayer(cellRuntime, result.tileUrl);\n        }\n    }\n}\n\nasync function initCurrentMultimapPage() {\n    const leadWeeks = getLeadWeeks(VARS.maxLead);\n    buildMultimapLayout(leadWeeks);\n\n    try {\n        await loadMaplibre();\n    } catch (error) {\n        console.error(\"MapLibre failed to load.\", error);\n        return;\n    }\n\n    if (!getMaplibreGlobal()) {\n        console.error(\"MapLibre is unavailable after load.\");\n        return;\n    }\n    if (!window.maplibregl && getMaplibreGlobal()) {\n        window.maplibregl = getMaplibreGlobal();\n    }\n\n    let baseStyle = null;\n    try {\n        baseStyle = await fetchPreparedStyle(DEFAULT_FLAVOR);\n    } catch (error) {\n        console.error(\"Failed to fetch prepared style\", error);\n        return;\n    }\n\n    ensureRuntimeContainer();\n\n    const defs = getCellDefinitions(leadWeeks);\n    const cells = defs\n        .map((def) => {\n            const container = document.getElementById(def.containerId);\n            if (!container) {\n                return null;\n            }\n            const map = createSingleMapInstance(container, baseStyle);\n            const cellRuntime = {\n                def,\n                map,\n                ready: false,\n                datasetId: \"\",\n                tileUrl: \"\",\n                stretch: \"\",\n                params: null,\n                rasterSlot: 0,\n                rasterSwapToken: 0,\n            };\n            map.on(\"load\", () => {\n                cellRuntime.ready = true;\n                applyBoundaryContrastOverrides(map);\n                if (cellRuntime.tileUrl) {\n                    setRasterLayer(map, cellRuntime.tileUrl, 0, TERRACOTTA_OPACITY);\n                    removeRasterSlot(map, 1);\n                }\n            });\n            return cellRuntime;\n        })\n        .filter(Boolean);\n\n    const cellsByKey = new Map(cells.map((cell) => [cell.def.key, cell]));\n\n    window.__grafanaMaplibreMultimap = {\n        cells,\n        cellsByKey,\n        refreshToken: 0,\n        pollHandle: null,\n    };\n\n    synchronizeMaps(cells);\n    await refreshAllCells(window.__grafanaMaplibreMultimap, VARS);\n\n    let pendingVars = null;\n    let pendingSince = 0;\n\n    window.__grafanaMaplibreMultimap.pollHandle = window.setInterval(async () => {\n        const observedVars = readVars();\n        const observedSig = JSON.stringify(observedVars);\n        const currentSig = JSON.stringify(VARS);\n        if (observedSig === currentSig) {\n            pendingVars = null;\n            pendingSince = 0;\n            return;\n        }\n\n        if (!pendingVars || JSON.stringify(pendingVars) !== observedSig) {\n            pendingVars = observedVars;\n            pendingSince = Date.now();\n            return;\n        }\n\n        if (Date.now() - pendingSince < VAR_STABILIZE_MS) {\n            return;\n        }\n\n        VARS = pendingVars;\n        pendingVars = null;\n        pendingSince = 0;\n\n        await refreshAllCells(window.__grafanaMaplibreMultimap, VARS);\n    }, POLL_INTERVAL_MS);\n}\n// EXTERNAL({\"panel_id\":\"singlemap-evaluation\",\"key\":\"call-function\"}):dfd44cgdurwn4f-singlemap-evaluation-call-function.js\n(() => {\n    function runCurrentMapPanel() {\n        return initCurrentMapPage();\n    }\n\n    runCurrentMapPanel();\n})();\n",
        "content": "<div id=\"map-container\" style=\"height:900px\" />",
        "contentPartials": [],
        "defaultContent": "",
        "editor": {
          "format": "auto",
          "language": "html"
        },
        "editors": [
          "afterRender"
        ],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "data",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "6.2.0",
      "targets": [
        {
          "datasource": {
            "type": "datasource",
            "uid": "grafana"
          },
          "path": "img",
          "queryType": "list",
          "refId": "A"
        }
      ],
      "title": "",
      "transparent": true,
      "type": "marcusolsson-dynamictext-panel"
    }
  ],
  "preload": false,
  "refresh": "",
  "schemaVersion": 40,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "text": "era5",
          "value": "era5"
        },
        "label": "Analysis",
        "name": "reanalysis",
        "options": [
          {
            "selected": false,
            "text": "CHIRPS v2",
            "value": "chirp_v2"
          },
          {
            "selected": false,
            "text": "CHIRPS v3",
            "value": "chirp_v3"
          },
          {
            "selected": false,
            "text": "IMERG Late Run",
            "value": "imerg_late"
          },
          {
            "selected": false,
            "text": "IMERG Final Run (Gauge-Adjusted)",
            "value": "imerg_final"
          },
          {
            "selected": true,
            "text": "ERA5",
            "value": "era5"
          }
        ],
        "query": "CHIRPS v2 : chirp_v2, CHIRPS v3 : chirp_v3, IMERG Late Run : imerg_late, IMERG Final Run (Gauge-Adjusted) : imerg_final, ERA5 : era5",
        "type": "custom"
      },
      {
        "current": {
          "text": "tahmo",
          "value": "tahmo"
        },
        "label": "Truth",
        "name": "truth",
        "options": [
          {
            "selected": true,
            "text": "TAHMO Stations",
            "value": "tahmo"
          },
          {
            "selected": false,
            "text": "TAHMO Area Average",
            "value": "tahmo_avg"
          },
          {
            "selected": false,
            "text": "GHCN Stations",
            "value": "ghcn"
          },
          {
            "selected": false,
            "text": "GHCN Area Average",
            "value": "ghcn_avg"
          }
        ],
        "query": "TAHMO Stations : tahmo, TAHMO Area Average : tahmo_avg, GHCN Stations : ghcn, GHCN Area Average : ghcn_avg",
        "type": "custom"
      },
      {
        "current": {
          "text": "global1_5",
          "value": "global1_5"
        },
        "label": "Grid",
        "name": "grid",
        "options": [
          {
            "selected": true,
            "text": "1.5",
            "value": "global1_5"
          },
          {
            "selected": false,
            "text": "0.25",
            "value": "global0_25"
          }
        ],
        "query": "1.5 : global1_5, 0.25 : global0_25",
        "type": "custom"
      },
      {
        "current": {
          "text": "7",
          "value": "7"
        },
        "label": "Agg Days",
        "name": "agg_days",
        "options": [
          {
            "selected": false,
            "text": "1",
            "value": "1"
          },
          {
            "selected": false,
            "text": "5",
            "value": "5"
          },
          {
            "selected": true,
            "text": "7",
            "value": "7"
          },
          {
            "selected": false,
            "text": "10",
            "value": "10"
          }
        ],
        "query": "1,5,7,10",
        "type": "custom"
      },
      {
        "current": {
          "text": "mae",
          "value": "mae"
        },
        "label": "Metric",
        "name": "metric",
        "options": [
          {
            "selected": true,
            "text": "MAE",
            "value": "mae"
          }
        ],
        "query": "MAE : mae",
        "type": "custom"
      },
      {
        "current": {
          "text": "precip",
          "value": "precip"
        },
        "label": "Product",
        "name": "product",
        "options": [
          {
            "selected": true,
            "text": "Precipitation",
            "value": "precip"
          }
        ],
        "query": "Precipitation : precip",
        "type": "custom"
      },
      {
        "current": {
          "text": "month_of_year",
          "value": "month_of_year"
        },
        "includeAll": false,
        "label": "Time Grouping",
        "name": "time_grouping",
        "options": [
          {
            "selected": false,
            "text": "None",
            "value": "None"
          },
          {
            "selected": true,
            "text": "Month of Year",
            "value": "month_of_year"
          }
        ],
        "query": "None : None, Month of Year : month_of_year",
        "type": "custom"
      },
      {
        "current": {
          "text": "M06",
          "value": "M06"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "SELECT t.value\nFROM unnest(\n  CASE\n    WHEN '$time_grouping' = 'month_of_year' THEN\n      ARRAY(\n        SELECT 'M' || lpad(gs::text, 2, '0')\n        FROM generate_series(1, 12) AS gs\n      )::text[]\n\n    WHEN '$time_grouping' = 'year' THEN\n      ARRAY(\n        SELECT gs::text\n        FROM generate_series(1998, 2024) AS gs\n      )::text[]\n\n    ELSE\n      ARRAY[]::text[]\n  END\n) AS t(value)\nORDER BY t.value;\n",
        "includeAll": false,
        "label": "Time Filter",
        "name": "time_filter",
        "options": [],
        "query": "SELECT t.value\nFROM unnest(\n  CASE\n    WHEN '$time_grouping' = 'month_of_year' THEN\n      ARRAY(\n        SELECT 'M' || lpad(gs::text, 2, '0')\n        FROM generate_series(1, 12) AS gs\n      )::text[]\n\n    WHEN '$time_grouping' = 'year' THEN\n      ARRAY(\n        SELECT gs::text\n        FROM generate_series(1998, 2024) AS gs\n      )::text[]\n\n    ELSE\n      ARRAY[]::text[]\n  END\n) AS t(value)\nORDER BY t.value;\n",
        "refresh": 1,
        "regex": "",
        "sort": 3,
        "type": "query"
      },
      {
        "current": {
          "text": "65024348549f647fe4c1795131ddb9ac",
          "value": "65024348549f647fe4c1795131ddb9ac"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "false",
          "value": "false"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Standardize Forecast Colors",
        "name": "standardize_forecast_colors",
        "options": [
          {
            "selected": true,
            "text": "False",
            "value": "false"
          }
        ],
        "query": "False : false",
        "type": "custom"
      },
      {
        "current": {
          "text": "false",
          "value": "false"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Standardize Lead Colors",
        "name": "standardize_lead_colors",
        "options": [
          {
            "selected": true,
            "text": "False",
            "value": "false"
          }
        ],
        "query": "False : false",
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {
    "hidden": true
  },
  "timezone": "utc",
  "title": "Station Data Evaluation Map",
  "uid": "dfd44cgdurwn4f",
  "version": 1,
  "weekStart": ""
}